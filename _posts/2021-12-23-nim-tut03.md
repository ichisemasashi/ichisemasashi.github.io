---
layout: post
title: Nim tutorial (III)
date:   2021-12-23
categories: 勝手翻訳 nim
---


# Nim Tutorial (Part III)

Author:   Arne Döring


## Introduction

> "大いなる力には、大いなる責任が伴う" -- Spider Man's Uncle

このドキュメントは、Nimのマクロシステムについてのチュートリアルです。マクロとは、コンパイル時に実行され、Nim の構文木を別の木に変換する関数です。

マクロで実装できるものの例。

- アサーションが失敗した場合に比較演算子の両辺を表示する assert マクロ。`myAssert(a == b)` は、`if a != b: quit($a " != " $b)` に変換されます。
- シンボルの値と名前を表示するデバッグマクロです。`myDebugEcho(a)` は、`echo "a." , a`に変換されます。 
- 式を記号的に微分すること。diff(a*pow(x,3) + b*pow(x,2) + c*x + d, x)` は、 `3*a*pow(x,2) + 2*b*x + c` に変換されます。

### マクロ引数

マクロ引数の種類は2つの顔を持つ。1 つの面はオーバーロードの解決に使用され、もう 1 つの面はマクロ本体内で使用されます。例えば、`macro foo(arg: int)` が `foo(x)` という式の中で呼ばれた場合、`x` は int と互換性のある型でなければなりませんが、マクロ本体の中では `arg` は `int` ではなく `NimNode` という型を持っています! なぜこのようにするのかは、後で具体的な例を見たときに明らかになります。

マクロに引数を渡すには2つの方法があります。引数には `typed` と `untyped` のどちらかを指定することができます。

### 未定義引数

マクロの未定義引数は、セマンティックチェックされる前にマクロに渡されます。つまり、マクロに渡される構文木は Nim にとって意味をなす必要はなく、唯一の制限は構文解析可能であることです。通常、マクロは引数をチェックしませんが、何らかの方法で変換結果の中でそれを使用します。マクロ展開の結果は常にコンパイラによってチェックされるので、奇妙なエラーメッセージを除けば、何も悪いことは起こりません。

`untyped` 引数の欠点は Nim のオーバーロードの解決と相性が悪いことです。

型付けされていない引数の利点はシンタックスツリーが非常に予測しやすく、 `typed` と比較して複雑でないことです。

### 型付き引数

型付き引数の場合、セマンティックチェッカーは引数上で実行され、マクロに渡される前に変換を行います。識別子ノードはシンボルとして解決され、暗黙の型変換は呼び出しとしてツリーに表示され、テンプレートは展開され、そしておそらく最も重要なのは、ノードが型情報を持つことです。型付き引数は引数リストで `typed` という型を持つことができます。しかし、 `int`, `float`, `MyObjectType` などの他のすべての型も型付き引数であり、それらはシンタックスツリーとしてマクロに渡されます。

### 静的引数

静的引数は、マクロに構文木ノードとしてではなく、値として値を渡す方法です。例えば、`macro foo(arg: static[int])` の式 `foo(x)` では、`x` は整数の定数である必要がありますが、マクロ本体では `arg` は通常の `int` 型のパラメータと同じようになります。

``` nim
import std/macros

macro myMacro(arg: static[int]): untyped =
  echo arg # 単なる int (7) で、`NimNode` ではありません。

myMacro(1 + 2 * 3)
```

### 引数としてのコードブロック

呼び出し式の最後の引数をインデントして別のコードブロックに渡すことが可能である。例えば、次のコード例は `echo` を呼び出す有効な方法です(推奨はしませんが)。

``` nim
echo "Hello ":
  let a = "Wor"
  let b = "ld!"
  a & b
```

マクロの場合、この呼び出し方は非常に便利で、この表記法を使えば、任意の複雑な構文木をマクロに渡すことができる。

### シンタックスツリー

Nim の構文木を作るには、Nim のソースコードがどのように構文木として表現されるのか、また、Nim のコンパイラが理解できるようにするには、その構文木がどのように見える必要があるのかを知る必要があります。Nim のシンタックスツリーのノードは [macros](macros.html) モジュールに記述されています。しかし、Nim のシンタックスツリーをよりインタラクティブに調べるには、 `macros.treeRepr` を使います。これは、引数式がどのようにツリー形式で表現されるかを調べたり、生成されたシンタックスツリーのデバッグ印刷に使用することができます。dumpTree` はあらかじめ定義されたマクロで、引数をツリー表現で表示するだけで、それ以外のことは何も行いません。以下は、そのような木表現の例である。

``` nim
dumpTree:
  var mt: MyType = MyType(a:123.456, b:"abcdef")

# output:
#   StmtList
#     VarSection
#       IdentDefs
#         Ident "mt"
#         Ident "MyType"
#         ObjConstr
#           Ident "MyType"
#           ExprColonExpr
#             Ident "a"
#             FloatLit 123.456
#           ExprColonExpr
#             Ident "b"
#             StrLit "abcdef"
```

### カスタムセマンティックチェック

マクロが引数に対して行うべき最初のことは、引数が正しい形式であるかどうかをチェックすることです。すべてのタイプの間違った入力をここでキャッチする必要はありませんが、マクロ評価中にクラッシュを引き起こす可能性があるものはすべてキャッチし、適切なエラー メッセージを作成する必要があります。`macros.expectKind` と `macros.expectLen` は良いスタートです。もっと複雑なチェックが必要な場合は、 `macros.error` proc で任意のエラーメッセージを作成することができます。

``` nim
macro myAssert(arg: untyped): untyped =
  arg.expectKind nnkInfix
```

### コードの生成

コードを生成する方法は2つあります。`newTree` と `newLit` の呼び出しを多く含む式でシンタックスツリーを作成する方法と、 `quote do:` 式でシンタックスツリーを作成する方法があります。最初のオプションはシンタックスツリーの生成を低レベルでコントロールするのに適していますが、2番目のオプションはより冗長ではありません。もし、 `newTree` と `newLit` のコールでシンタックスツリーを作成する場合は、マクロ `macros.dumpAstGen` が冗長性を保つための手助けをしてくれます。

`quote do:` では、文字通り生成したいコードを書くことができます。バックティックは、`NimNode` シンボルから生成される式にコードを挿入するために使用されます。

``` nim
macro a(i) = quote do: let `i` = 0
a b
```

バックティックが必要な場合は、カスタムのプリフィックス演算子を定義することができる。

``` nim
macro a(i) = quote("@") do: assert @i == 0
let b = 0
a b
```

注入されたシンボルは、シンボルに解決するときにアクセントの引用符が必要です。

``` nim
macro a(i) = quote("@") do: let `@i` == 0
a b
```

生成された構文木には `NimNode` 型のシンボルだけを注入するようにしてください。任意の値を `NimNode` 型の式木に変換するために `newLit` を使用すると、安全に注入することができます。

``` Nim
import std/macros

type
  MyType = object
    a: float
    b: string

macro myMacro(arg: untyped): untyped =
  var mt: MyType = MyType(a:123.456, b:"abcdef")

  # ...

  let mtLit = newLit(mt)

  result = quote do:
    echo `arg`
    echo `mtLit`

myMacro("Hallo")
```

`myMacro` を呼び出すと、次のようなコードが生成されます。

``` nim
echo "Hallo"
echo MyType(a: 123.456'f64, b: "abcdef")
```

### 最初のマクロを作る

マクロを書くための出発点として、先ほどの `myDebug` マクロを実装する方法を紹介します。まず最初に行うべきことは、マクロの使い方の簡単な例を作って、引数を表示することです。こうすることで、正しい引数がどのようなものであるべきかを知ることができます。

``` Nim
import std/macros

macro myAssert(arg: untyped): untyped =
  echo arg.treeRepr

let a = 1
let b = 2

myAssert(a != b)
```

``` Nim
Infix
  Ident "!="
  Ident "a"
  Ident "b"
```

出力から、引数が infix 演算子であること（node kind が "Infix" ）と、2 つのオペランドがインデックス 1 と 2 であることを確認することができる。この情報をもとに、実際のマクロを記述することができる。

```Nim
import std/macros

macro myAssert(arg: untyped): untyped =
  # すべてのノードの種類識別子の先頭に "nnk "が付く。
  arg.expectKind nnkInfix
  arg.expectLen 3
  # 文字列リテラルとしての演算子
  let op  = newLit(" " & arg[0].repr & " ")
  let lhs = arg[1]
  let rhs = arg[2]

  result = quote do:
    if not `arg`:
      raise newException(AssertionDefect,$`lhs` & `op` & $`rhs`)

let a = 1
let b = 2

myAssert(a != b)
myAssert(a == b)
```

これが生成されるコードです。マクロが実際に生成したものをデバッグするには、マクロの最後の行で `echo result.repr` というステートメントを使用します。これは、この出力を得るために使用されたステートメントでもあります。

``` nim
if not (a != b):
raise newException(AssertionDefect, $a & " != " & $b)
```

### With Power Comes Responsibility

Macros are very powerful. A piece of good advice is to use them as little as possible, but as much as necessary. Macros can change the semantics of expressions, making the code incomprehensible for anybody who does not know exactly what the macro does with it. So whenever a macro is not necessary and the same logic can be implemented using templates or generics, it is probably better not to use a macro. And when a macro is used for something, the macro should better have a well-written documentation. For all the people who claim to write only perfectly self-explanatory code: when it comes to macros, the implementation is not enough for documentation.

### Limitations

Since macros are evaluated in the compiler in the NimVM, macros share all the limitations of the NimVM. They have to be implemented in pure Nim code. Macros can start external processes on the shell, but they cannot call C functions except those that are built in the compiler.

## More Examples

This tutorial can only cover the basics of the macro system. There are macros out there that could be an inspiration for you of what is possible with it.

### Strformat

In the Nim standard library, the `strformat` library provides a macro that parses a string literal at compile time. Parsing a string in a macro like here is generally not recommended. The parsed AST cannot have type information, and parsing implemented on the VM is generally not very fast. Working on AST nodes is almost always the recommended way. But still `strformat` is a good example for a practical use case for a macro that is slightly more complex than the `assert` macro.

[Strformat](https://github.com/nim-lang/Nim/blob/5845716df8c96157a047c2bd6bcdd795a7a2b9b1/lib/pure/strformat.nim#L280)

### Ast Pattern Matching

Ast Pattern Matching is a macro library to aid in writing complex macros. This can be seen as a good example of how to repurpose the Nim syntax tree with new semantics.

[Ast Pattern Matching](https://github.com/krux02/ast-pattern-matching)

### OpenGL Sandbox

This project has a working Nim to GLSL compiler written entirely in macros. It scans recursively through all used function symbols to compile them so that cross library functions can be executed on the GPU.

[OpenGL Sandbox](https://github.com/krux02/opengl-sandbox)
