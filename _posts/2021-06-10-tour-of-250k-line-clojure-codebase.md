---
layout: post
title: Tour of our 250k line Clojure codebase
date:   2021-06-10
categories: Clojure 勝手翻訳
---

https://tech.redplanetlabs.com/2021/06/03/tour-of-our-250k-line-clojure-codebase/?utm_source=rss&utm_medium=rss&utm_campaign=tour-of-our-250k-line-clojure-codebase

# 25万行のClojureコードベースのツアー

2021年6月3日～ ネイサン・マーズ	

レッド・プラネット・ラボでは、何年も前から新しいタイプの開発者ツールを静かに開発しています。私たちのツールは、大規模なエンド・ツー・エンドのアプリケーションを構築するためのコストを何桁も削減してくれます。

私たちのコードベースは、25万行のClojureで構成されており、ソースコードとテストコードに均等に分けられています。これは、世界最大のClojureコードベースの1つです。この記事では、このような規模のプロジェクトをチーム内で理解できるようにコードを整理する方法、Clojureのユニークな特性を活用した開発およびテストのテクニック、使用している主要なライブラリの概要をご紹介します。


## 言語の中のカスタム言語

私たちのコードベースの最もクールな部分の一つは、その基盤となる新しい汎用言語です。この言語のセマンティクスはClojureとは大幅に異なりますが、異なる動作を表現するためにマクロを使用して完全にClojure内で定義されています。また、[ASMライブラリ](https://asm.ow2.io/)を使用してバイトコードに直接コンパイルします。システムの残りの部分は、この言語とバニラClojureの両方を使って構築され、シームレスに相互運用されています。

バニラClojureにはない、この言語の特徴的な機能の1つがファーストクラスの継続です。この言語の継続の表現方法は、非同期、並列、リアクティブ・プログラミングに非常に適しています。これらはすべて、私たちが構築している大規模な分散インフラの基礎となるものです。

Clojureで全く異なるセマンティクスを持つ新しい言語を構築できるということは、Clojureがいかに強力であるかを示しています。レキシング、パーシング、データタイプ、名前空間、不変のデータ構造、そしてClojureとJVMのライブラリエコシステム全体など、この方法で言語を構築すると「無料で」得られるものがたくさんあります。最終的に、私たちの新しい言語はClojureの中で定義されているので、ClojureとJVMの両方とのシームレスな相互運用性の恩恵を受けることができます。

大多数のアプリケーションでは、私たちのような完全な言語を開発する必要はないでしょう。しかし、焦点を絞ったDSLが適している使用例はたくさんあり、その例もあります。Clojureでは、マクロやメタプログラミングによってコードの解釈方法をカスタマイズすることができますが、これは非常に強力な機能です。


## 型/スキーマチェック

どんなコードベースでも、作成、管理、操作されるデータが中心となります。システム内を飛び交うデータを慎重かつ明確にドキュメント化することが必要です。同時に、型やスキーマのアノテーションはオーバーヘッドを増やしてしまうので、やりすぎないように慎重に行うことが重要です。

私たちはコードベース内でデータ型を定義するために、[Schemaライブラリ](https://github.com/plumatic/schema)を使用しています。使いやすく、任意の述語や列挙型、unionなど、型以外のスキーマ制約を柔軟に定義できるのが気に入っています。私たちのコードベースには約600の型定義があり、そのほとんどがSchemaを使ってアノテーションされています。

Schemaの周辺にはdefrecord+というヘルパーがあり、検証も行うコンストラクタ関数を定義しています（例えばFoo型の場合、"->valid-Foo "と "map->valid-Foo "を生成します）。これらの関数は、スキーマチェックに失敗した場合、記述的な例外を投げます。

Clojureには静的な型チェックはありません。また、静的な型チェックでは、スキーマを使用して定義するすべての種類の制約をチェックすることはできません（例：数値の値が特定の範囲内にあること）。私たちは、どちらかにスキーマチェックを挿入するだけでよいことがわかりました。

- 型の構築では、自動生成された「有効な」コンストラクタ関数がすべてのセレモニーを取り除きます。レコードを作成するときにエラーを検出することは、後で使用するときよりもはるかに優れています。作成時には、問題をデバッグするために必要なコンテキストがあるからです。
- コードベースの中には、様々な種類のものが流れる戦略的な場所がいくつかあります。

関数の引数や戻り値の型については、たまに注釈をつける程度です。その代わり、コードを理解するためには、名前の付け方に一貫性があれば十分だと考えています。コードベースには約500のアサーションが含まれていますが、これらは単純な型チェックではなく、より高レベルのプロパティに関するものがほとんどです。

私たちがスキーマの定義と実施のためにとったアプローチは、軽量で包括的であり、邪魔になることはありません。Clojureに静的な型付けがないことは、Clojureを使ったことのない多くのプログラマーを不安にさせますが、私たちが言えることは、コードをどのように構成するかを少し考えれば、まったく問題にならないということです。そして、物事を動的に行うことは、静的な型システムでは不可能な強い制約を課すことができることを意味します。


## マルチモジュールのリポジトリ設定

私たちのコードベースは1つのgit repoに存在し、4つのモジュールで実装を分割しています。

- "core"は、コンパイラの定義と、それに対応する並列プログラミングの抽象化を含んでいます。
- "distributed"は、これらの並列プログラミングの抽象化を分散クラスタとして実装します。
- "rpl-specter"は、[Specter](https://github.com/redplanetlabs/specter)の内部フォークで、大量の機能を追加しています。
- "webui": 製品のフロントエンドを実装しています。

ビルドには[Leiningen](https://github.com/technomancy/leiningen)と[deps.edn](https://clojure.org/guides/deps_and_cli)を使用しています。deps.ednファイルでローカルターゲットを依存関係にあるものとして指定する機能は、私たちのマルチモジュールのセットアップにとって重要であり、ソースツリーの基本的な構成は次のようになっています。

```
project.clj
deps.edn
rpl-specter/project.clj
rpl-specter/deps.edn
core/project.clj
core/deps.edn
distributed/project.clj
distributed/deps.edn
webui/project.clj
webui/deps.edn
```

deps.ednファイルから「distributed」の部分を抜粋してみました。

```
{:deps {rpl/core {:local/root "../core"
                  :deps/manifest :deps}
        ...
        }
  ...
  }
```

この設定により、いずれかのモジュール内で開発を行い、明示的な Maven の依存関係を作らなくても、他のモジュールのソース変更を自動的に確認することができます。

テストの実行や REPL のロードのためにコードベース全体をロードするのは非常に時間がかかるため（主にカスタム言語を使用したコードのコンパイルが原因）、AOT コンパイルを多用して開発を高速化しています。私たちはほとんどの時間を「distributed」で開発しているので、「core」をAOTコンパイルしてスピードアップしています。


## Specterによるポリモーフィック・データ

Specterは、データ構造、特に入れ子や再帰的なデータを扱う能力を強化するために開発されたライブラリです。Specterは、データ構造への「パス」の概念に基づいています。パスは、データ構造のルートから任意の数の値に「ナビゲート」することができます。パスにはトラバース、ビュー、フィルタなどが含まれ、それらは深く合成可能です。

コンパイラはコードを抽象的な表現にコンパイルし、言語で可能な操作の種類ごとに明確なレコードタイプを持っています。すべての操作タイプには、統一された方法で公開しなければならないさまざまな属性があります。例えば、これらの属性の1つに「必要なフィールド」があります。これは、その操作のクロージャ内にあるフィールドで、仕事をするのに必要なものです。このポリモーフィックな動作を表現する典型的な方法は、次のようなインターフェースやプロトコルを使うことです。


## Componentによる複雑なサブシステムの構築
## with-redefsを使ったテスト
## マクロの使用
## 決定論的シミュレーション
## フロントエンド
## ライブラリ
## まとめ





www.DeepL.com/Translator（無料版）で翻訳しました。


