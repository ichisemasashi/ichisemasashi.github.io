---
layout: post
title: Nim tutorial (I)
date:   2021-11-21
categories: 勝手翻訳 nim
---

# Nim Tutorial (Part I)

Author:   Andreas Rumpf

## Introduction

```{=html
<blockquote><p>
"人間は目の動物ですから、美しいものを望みます。 -- schöne Dinge wünsch ich mir.""
</p></blockquote>}
```
このドキュメントは、プログラミング言語 *Nim* のチュートリアルです。

このチュートリアルでは、変数や型、文などの基本的なプログラミングの概念を知っていることを前提としています。
このチュートリアルでは、変数、型、ステートメントなどの基本的なプログラミングの概念に精通していることを前提としています。

Nimを学ぶための他のリソースをいくつか紹介します。

-   [Nim Basics tutorial](https://narimiran.github.io/nim-basics/) - 前述のコンセプトを優しく紹介
-   [Learn Nim in 5 minutes](https://learnxinyminutes.com/docs/nim/) -
    5分でわかるNimの魅力
-   [The Nim manual](manual.html) - 他にもたくさんの高度な言語機能の例があります。

このチュートリアルのすべてのコード例は、Nimの他のドキュメントにあるものと同様に、[Nim style guide](nep1.html)に従っています。

## The first program

まず、"hello world "のプログラムを修正して、ツアーを開始します。

```Nim
# これはコメントです。
echo "What's your name? "
var name: string = readLine(stdin)
echo "Hi, ", name, "!"
```

このコードを "greetings.nim "というファイルに保存します。それでは、コンパイルして実行してみましょう。
```
nim compile --run greetings.nim
```

`run` [switch](nimc.html#compiler-useage-commandminusline-switch) を使うと、Nim はコンパイル後に自動的にファイルを実行します。プログラムにコマンドライン引数を与えるには、ファイル名の後に引数を追加します。

```
nim compile --run greetings.nim arg1 arg2
```

よく使うコマンドやスイッチには略語があるので、それを利用することもできます。

    nim c -r greetings.nim

これは**デバッグバージョン**です。リリース版をコンパイルするには

    nim c -d:release greetings.nim

デフォルトでは、Nim コンパイラは、デバッグの楽しみのために多数のランタイムチェックを生成します。`-d:release`では、[いくつかのチェックがオフになり、最適化がオンになります](nimc.html#compiler-useage-compileminustime-symbols)。

ベンチマークやプロダクションコードには、`-d:release` スイッチを使用してください。C のような安全ではない言語と性能を比較する場合は、意味のある比較可能な結果を得るために、`-d:danger` スイッチを使用してください。そうしないと、C言語では**利用できない**チェックによって、Nimが不利になる可能性があります。

プログラムが何をしているかは一目瞭然だと思いますが、ここでは構文を説明します。インデントされていない文は、プログラムの開始時に実行されます。インデントとは、Nim がステートメントをグループ化する方法です。インデントはスペースのみで行われ、タビュレータは使用できません。

文字列リテラルはダブルクオートで囲まれています。`var`文は、[readLine](io.html#readLine,File)プロシージャが返す値を持つ、`string`型の`name`という新しい変数を宣言します。コンパイラは[readLine](io.html#readLine,File)が文字列を返すことを知っているので、宣言の中で型を省略することができます(これは `local type inference`と呼ばれます)。ですから、これもうまくいきます。

```Nim
var name = readLine(stdin)
```

これは基本的に、Nimに存在する唯一の型推論の形式であることに注意してください。これは、簡潔さと読みやすさの間の良い妥協点です。

"hello world "のプログラムには、コンパイラがすでに知っているいくつかの識別子が含まれています。例えば、`echo`、[readLine](io.html#readLine,File)などです。これらの組み込み関数は [system](system.html) モジュールで宣言されており、他のモジュールから暗黙のうちにインポートされています。

## 字句の要素

他のプログラミング言語と同様に、Nim は（文字列）リテラル、識別子、キーワード、コメント、演算子、その他の句読点で構成されています。

### 文字列リテラルと文字リテラル

文字列リテラルはダブルクォートで、文字リテラルはシングルクォートで囲みます。特殊文字は`\`でエスケープされます。`\n`は改行、`\t`はタブレータなどです。文字列リテラルには *生* のものもあります。

```Nim
r"C:\program files\nim"
```

生のリテラルでは、バックスラッシュはエスケープ文字ではありません。

文字列リテラルの3番目で最後の書き方は、*long-string literals*です。文字列リテラルは、3つの引用符を使って書きます。`""" …”””` また、複数の行にまたがることができ、`\`もエスケープ文字ではありません。これは、HTMLコードのテンプレートを埋め込むときなどに非常に便利です。

### コメント

コメントは、文字列または文字リテラルの外側のどこかで、ハッシュ文字 `#` で始まります。ドキュメントのコメントは `##` で始まります。

```Nim
# コメント

var myVariable: int ## ドキュメントのコメント
```

ドキュメントのコメントはトークンです。構文ツリーに属するため、入力ファイルの特定の場所でしか使用できません。この機能により、よりシンプルなドキュメント生成が可能になります。

複数行のコメントは、`#[`で始まり、`]#`で終わります。マルチラインコメントはネストすることもできます。

```Nim
#[
この中にNimコードのテキストをインデントの制限なしにコメントアウトすることができます。
      yes("May I ask a pointless question?")
  #[
     Note: these can be nested!!
  ]#
]#
```

### 数値

数字のリテラルは、他の多くの言語と同じように書かれます。`1_000_000`（one million）のように、アンダースコアを使うこともできますが、これは読みやすくするためです。`1.0e9`（10億）のように、ドット（または「e」や「E」）を含む数字は浮動小数点リテラルです。16進数リテラルにはプレフィックスとして`0x`、2進数リテラルには`0b`、8進数リテラルには`0o`が付きます。先頭の0だけでは8進数にはなりません。

## var文

var文は、新しいローカル変数またはグローバル変数を宣言します。

```Nim
var x, y: int # x と y が `int` 型であることを宣言します。
```

`var`キーワードの後にインデントを使用すると、変数のセクション全体を列挙することができます。

```Nim
var
  x, y: int
  # ここでもコメントが発生します
  a, b, c: string
```


## 定数

定数とは、ある値に束縛される記号です。定数の値は変更できません。コンパイラは、定数宣言の式をコンパイル時に評価できなければなりません。

```Nim
const x = "abc" # 定数xは、文字列 "abc "を含みます。
```


インデントは、`const`キーワードの後に使用して、定数のセクション全体を列挙することができます。

```Nim
const
  x = 1
  # ここでもコメントが発生します
  y = 2
  z = y + 5 # 演算が可能
```


## letステートメント

`let`文は、`var`文と同じように動作しますが、宣言されたシンボルは、*単式代入*変数となります。初期化された後、その値は変更できません。

```Nim
let x = "abc" # 新しい変数 `x` を導入し、それに値をバインドします。
x = "xyz"     # Illegal: assignment to `x`
```

`let`と`const`の違いは、`let`は再割り当てできない変数を導入すること、`const`は「コンパイル時の評価を強制してデータセクションに入れる」ことです。

```Nim
const input = readLine(stdin) # Error: constant expression expected
```

```Nim
let input = readLine(stdin) # works
```



## 代入文

代入文は、変数に新しい値を割り当てるもので、より一般的には記憶場所に値を割り当てます。

```Nim
var x = "abc" # 新しい変数 `x` を導入し、その値を割り当てます。
x = "xyz"     # 新しい値を`x`に割り当てる
```

`=` は *代入演算子* です。代入演算子はオーバーロードすることができます。1つの代入文で複数の変数を宣言しても、すべての変数が同じ値になります。

```Nim
var x, y = 3  # 変数 `x` と `y` に 3 を割り当てます。
echo "x ", x  # outputs "x 3"
echo "y ", y  # outputs "y 3"
x = 42        # `y`を変更せずに`x`を42に変更します。
echo "x ", x  # outputs "x 42"
echo "y ", y  # outputs "y 3"
```


## 制御フロー文

greetingsのプログラムは、3つの文を順番に実行していきます。分岐やループも必要なので、最も原始的なプログラムだけがこれで済む。

### if文

if文は、制御の流れを分岐させる一つの方法です。

```Nim
let name = readLine(stdin)
if name == "":
  echo "Poor soul, you lost your name?"
elif name == "name":
  echo "Very funny, your name is name."
else:
  echo "Hi, ", name, "!"
```


ゼロまたはそれ以上の `elif` 部分があります。また、`else`の部分はオプションです。 キーワード `elif` は `else if` の略で、過剰なインデントを避けるのに便利です。(`""`は空の文字列です。 文字を含みません)。

### Caseステートメント

ブランチのもう一つの方法は、ケース・ステートメントです。case statementはマルチブランチです。

```Nim
let name = readLine(stdin)
case name
of "":
  echo "Poor soul, you lost your name?"
of "name":
  echo "Very funny, your name is name."
of "Dave", "Frank":
  echo "Cool name!"
else:
  echo "Hi, ", name, "!"
```

見ての通り、`of`の枝には、カンマで区切られた値のリストも許されます。

case文では、整数、その他の序列型、文字列を扱うことができます。(整数やその他の序列型では、値の範囲を指定することもできます。

``` nim
# この記述については後で説明します。
from std/strutils import parseInt
echo "A number please: "
let n = parseInt(readLine(stdin))
case n
of 0..2, 4..7: echo "The number is in the set: {0, 1, 2, 4, 5, 6, 7}"
of 3, 8: echo "The number is 3 or 8"
```

その理由は、`n` に含まれるすべての値をカバーしなければならないのに、このコードでは `0..8` という値しか扱わないからです。他のすべての可能な整数をリストアップするのはあまり実用的ではないので（範囲表記のおかげで可能ですが）、他のすべての値に対しては何もしないようにコンパイラに指示することでこれを修正します。

``` nim
...
case n
of 0..2, 4..7: echo "The number is in the set: {0, 1, 2, 4, 5, 6, 7}"
of 3, 8: echo "The number is 3 or 8"
else: discard
```

空の[discard文](#procedures-discard-statement)は、*何もしない*文です。コンパイラは、else部分を持つcase文は失敗しないことを知っているので、このエラーは消えます。文字列のケースが常に `else` の分岐を必要とするのはこのためです。

一般的に、case文はサブレンジ型や列挙型に使用され、可能性のあるすべての値をカバーしているかどうかをコンパイラがチェックするのに非常に役立ちます。

### while文

while文は、シンプルなループ構造です。

```Nim
echo "What's your name? "
var name = readLine(stdin)
while name == "":
  echo "Please tell me your name: "
  name = readLine(stdin) # ここでは新しい変数を宣言しないので、`var`はありません。
```

この例では、ユーザーが何も入力しない（RETURNを押すだけ）限り、ユーザーに名前を尋ね続けるwhileループを使用しています。

### For文

`for`文は、*iterator*が提供する任意の要素をループするための構文です。この例では、組み込みの[countup](system.html#countup.i,T,T,Positive)というイテレータを使っています。

```Nim
echo "Counting to ten: "
for i in countup(1, 10):
  echo i
# --> Outputs 1 2 3 4 5 6 7 8 9 10 on different lines
```

変数 `i` は `for` ループによって暗黙的に宣言されており、型は `int` です。なぜなら、[countup](system.html#countup.i,T,T,Positive)が返す値がint型だからです。i` は 1, 2, ..., 10 の値を実行します。それぞれの値は `echo` されます。このコードも同じです。

``` nim
echo "Counting to 10: "
var i = 1
while i <= 10:
  echo i
  inc i # increment i by 1
# --> Outputs 1 2 3 4 5 6 7 8 9 10 on different lines
```

プログラムではカウントアップが頻繁に行われるので、Nimには同じことを行う[...](system.html#...i,T,T)イテレータもあります。

``` nim
for i in 1 .. 10:
...
```

カウントダウンも同様に簡単に実現できます（ただし、必要とされる頻度は低い）。

``` nim
echo "Counting down from 10 to 1: "
for i in countdown(10, 1):
  echo i
# --> Outputs 10 9 8 7 6 5 4 3 2 1 on different lines
```

ゼロベースのカウントには、2つのショートカット `...<` と `.... ^1` ([後方指数演算子](system.html#%5E.t%2Cint))を使って、上位の指数よりも1つ小さい数までのカウントを簡単に行うことができます。

``` nim
for i in 0 ..< 10:
  ...  # the same as 0 .. 9
```

or

``` nim
var s = "some string"
for i in 0 ..< s.len:
  ...
```

or

``` nim
var s = "some string"
for idx, c in s[0 .. ^1]:
  ... # ^1は最後の要素、^2はその1つ前の要素、というように。
```

コレクション（配列やシーケンスなど）のための便利なイテレータには次のようなものがあります。
* `items` と `mitems` は、それぞれイミュータブルとミュータブルな要素を提供します。
* 要素とインデックス番号を提供する `pairs` と `mpairs` (それぞれイミュータブルとミュータブル)

```Nim
for index, item in ["a","b"].pairs:
  echo item, " at index ", index
# => a at index 0
# => b at index 1
```

### スコープとブロックステートメント

制御フロー文には、新しいスコープを開くという、これまで説明してこなかった機能があります。つまり、次の例では、ループの外では `x` にアクセスできないということです。

```Nim
while false:
  var x = "hi"
echo x # does not work
```

while（for）文は、暗黙のブロックを導入します。識別子は、宣言されたブロックの中でのみ表示されます。`block`文を使うと、新しいブロックを明示的に開くことができます。

```Nim
block myblock:
  var x = "hi"
echo x # does not work either
```

ブロックの*ラベル*(例では`myblock`)はオプションです。

### break文

break文でブロックを途中で抜けることができます。break文は、`while`、`for`、`block`のいずれかの文を残します。ブロックのラベルが与えられていない限り、最も内側の構造体を残します。

```Nim
block myblock:
  echo "entering block"
  while true:
    echo "looping"
    break # ループを離れるが、ブロックを離れません。
  echo "still in block"
echo "outside the block"

block myblock2:
  echo "entering block"
  while true:
    echo "looping"
    break myblock2 # ブロック（とループ）を離れる
  echo "still in block" # プリントされない
echo "outside the block"
```

### Continueステートメント

他の多くのプログラミング言語と同様に、`continue`文は次の反復処理を直ちに開始します。

```Nim
for i in 1 .. 5:
  if i <= 3: continue
  echo i # will only print 4 and 5
```

### When文

例:

```Nim
when system.hostOS == "windows":
  echo "running on Windows!"
elif system.hostOS == "linux":
  echo "running on Linux!"
elif system.hostOS == "macosx":
  echo "running on Mac OS X!"
else:
  echo "unknown operating system"
```

`when`文は、`if`文とほぼ同じですが、以下のような違いがあります。

- 各条件はコンパイラによって評価されるため、定数式である必要があります。
- 枝の中の文は新しいスコープを開きません。
- コンパイラはセマンティクスをチェックして、`true`と評価された最初の条件に属するステートメントに対して*のみ*コードを生成します。

この `when` 文は、C言語の `#ifdef`構造と同様に、プラットフォーム固有のコードを記述するのに便利です。

## ステートメントとインデント

さて、基本的な制御フローのステートメントについて説明しましたが、Nimのインデントルールに戻りましょう。

Nimでは、*単純な文*と*複雑な文*を区別しています。*単純な文*には、他の文を含めることはできません。代入、プロシージャコール、`return`文などはすべて単純な文です。*複雑なステートメント*は、`if`, `when`, `for`, `while` のように、他のステートメントを含むことができます。曖昧さを避けるために、複雑なステートメントは常にインデントされなければなりませんが、単一の単純なステートメントはインデントされません。

``` nim
# シングルアサインメントの場合、インデントは不要:
if x: x = false
# ネストしたif文に必要なインデント。
if x:
  if y:
    y = false
  else:
    y = true

# 条件の後に2つのステートメントが続くので、インデントが必要です。
if x:
  x = false
  y = false
```

*式*とは、通常は値を生成するステートメントの一部です。if文の条件は式の一例です。式は、読みやすくするために、特定の場所にインデントを入れることができます。

``` nim
if thisIsaLongCondition() and
    thisIsAnotherLongCondition(1,
       2, 3, 4):
  x = true
```

原則として、式の中でのインデントは、演算子の後、開括弧の後、カンマの後に行うことができます。

括弧やセミコロン `(;)` を使えば、式だけが許される文を使うことができます。

```Nim
# はコンパイル時にfac(4)を計算します。
const fac4 = (var x = 1; for i in 1..4: x *= i; x)
```

## プロシージャ

例題の[echo](system.html#echo,varargs%5Btyped,%5D)や[readLine](io.html#readLine,File)のような新しいコマンドを定義するには、*procedure*という概念が必要です(言語によっては、*method*や*functions*と呼ぶこともあります)。(Nimでは新しいプロシージャは`proc`キーワードで定義します。

```Nim
proc yes(question: string): bool =
  echo question, " (y/n)"
  while true:
    case readLine(stdin)
    of "y", "Y", "yes", "Yes": return true
    of "n", "N", "no", "No": return false
    else: echo "Please be clear: yes or no"

if yes("Should I delete all your important files?"):
  echo "I'm sorry Dave, I'm afraid I can't do that."
else:
  echo "I think you know what the problem is just as well as I do."
```

この例では、`yes`という名前のプロシージャを使って、ユーザに`質問`を投げかけ、"yes"（あるいはそれに類するもの）と答えた場合にはtrueを返し、"no"（あるいはそれに類するもの）と答えた場合にはfalseを返します。`return`文はすぐにプロシージャ（つまりwhileループ）を抜けます。`(question: string): bool`構文は、プロシージャが `string` 型の `question` という名前のパラメータを期待し、`bool` 型の値を返すことを説明しています。`bool`型は組み込みです。`bool`の有効な値は`true`と`false`だけです。if文やwhile文の条件は，`bool`型でなければなりません．

いくつかの用語について説明しますと、例題の中で `question` は (形式的な) *パラメータ* と呼ばれ、`"Should I..."` はこのパラメータに渡される *引数* と呼ばれます。

### Result変数

値を返すプロシージャには、戻り値を表す暗黙の `result` 変数が宣言されています。式を伴わない `return` 文は `return result` の省略形です。プロシージャの終了時に `return` ステートメントがない場合には、`result` 値は常に自動的に返されます。

```Nim
proc sumTillNegative(x: varargs[int]): int =
  for i in x:
    if i < 0:
      return
    result = result + i

echo sumTillNegative() # echoes 0
echo sumTillNegative(3, 4, 5) # echoes 12
echo sumTillNegative(3, 4 , -1 , 6) # echoes 7
```

変数 `result` は、関数の開始時にすでに暗黙のうちに宣言されているので、たとえば 'var result' で再度宣言すると、同じ名前の通常の変数にシャドウイングされてしまいます。また、result変数はその型のデフォルト値ですでに初期化されています。参照データ型はプロシージャの開始時には `nil` になっているので、手動で初期化する必要があるかもしれないことに注意してください。

`return`文を持たず、特別な`result`変数を使用しないプロシージャは、その最後の式の値を返します。例えば，次のようなプロシージャがあります．

```Nim
proc helloWorld(): string =
  "Hello, World!"
```

文字列 "Hello, World!"を返します。

### パラメータ

パラメータはプロシージャ本体では不変です。デフォルトでは、パラメータの値は変更できません。これは、コンパイラが最も効率的な方法でパラメータの受け渡しを実装するためです。プロシージャ内で変更可能な変数が必要な場合は、プロシージャ本体で `var` と宣言しなければなりません。パラメータ名をシャドウイングすることは可能で、実際に慣用句となっています。

```Nim
proc printSeq(s: seq, nprinted: int = -1) =
  var nprinted = if nprinted == -1: s.len else: min(nprinted, s.len)
  for i in 0 ..< nprinted:
    echo s[i]
```


プロシージャが呼び出し元のために引数を変更する必要がある場合は、`var`パラメータを使用できます。

```Nim
proc divmod(a, b: int; res, remainder: var int) =
  res = a div b        # integer division
  remainder = a mod b  # integer modulo operation

var
  x, y: int
divmod(8, 5, x, y) # modifies x and y
echo x
echo y
```


この例では，`res`と`remainder`は`varパラメータ`です．varパラメータはプロシージャで変更することができ，その変更は呼び出し側から見えるようになっています．上記の例では，varパラメータを使用する代わりにタプルを戻り値として使用する方が良いことに注意してください．

### Discardステートメント

副作用のためだけに値を返すプロシージャを呼び出し、その戻り値を無視するには、`discard`文を **必ず** 使用しなければなりません。Nimでは戻り値を黙って捨てることはできません。

``` nim
discard yes("May I ask a pointless question?")
```

呼び出された proc/iterator が `discardable` プラグマで宣言されている場合、戻り値は暗黙のうちに無視できます。

```Nim
proc p(x, y: int): int {.discardable.} =
  return x + y

p(3, 4) # now valid
```


### 名前付き引数

プロシージャには多くのパラメータがあり、パラメータの出現順序がはっきりしないことがよくあります。これは、複雑なデータ型を構築するプロシージャの場合に特に当てはまります。そこで、プロシージャの引数に名前を付けて、どの引数がどのパラメータに属するかを明確にすることができます。

``` nim
proc createWindow(x, y, width, height: int; title: string;
                  show: bool): Window =
  ...
var w = createWindow(show = true, title = "My Application",
                     x = 0, y = 0, height = 600, width = 800)
```

名前付き引数を使って `createWindow` を呼び出しているので、引数の順序はもう問題ではありません。名前付き引数と順序付き引数を混在させることも可能ですが、あまり読みやすくはありません。

``` nim
var w = createWindow(0, 0, title = "My Application",
                     height = 600, width = 800, true)
```

コンパイラは、各パラメータが正確に1つの引数を受け取ることをチェックします。

### デフォルト値

`createWindow` procを使いやすくするために、`default values`を提供するべきです。これは、呼び出し側が指定しない場合に引数として使用される値です。

``` nim
proc createWindow(x = 0, y = 0, width = 500, height = 700,
                  title = "unknown",
                  show = true): Window =
  ...
var w = createWindow(title = "My Application", height = 600, width = 800)
```

これで、`createWindow` の呼び出しでは、デフォルトと異なる値を設定するだけになります。

型推論はデフォルト値を持つパラメータでも機能することに注意してください。例えば、`title: string = "unknown"`と書く必要はありません。

### オーバーロードされたプロシージャ

Nimでは、C++のように手続きをオーバーロードすることができます。

``` nim
proc toString(x: int): string =
  result =
    if x < 0: "negative"
    elif x > 0: "positive"
    else: "zero"

proc toString(x: bool): string =
  result =
    if x: "yep"
    else: "nope"

assert toString(13) == "positive" # calls the toString(x: int) proc
assert toString(true) == "yep"    # calls the toString(x: bool) proc
```

(なお、`toString` は通常、Nim では [$](dollars.html) 演算子です)。コンパイラは、`toString` の呼び出しに最も適した proc を選択します。このオーバーロード解決アルゴリズムが具体的にどのように機能するかは、ここでは説明しません。-- 詳細はマニュアルを参照してください。曖昧な呼び出しはエラーとして報告されます。

### 演算子

Nim の標準ライブラリはオーバーロードを多用しています。その理由のひとつは、`+` のような各演算子がオーバーロードされた proc に過ぎないからです。パーサーでは、*インフィックス記法*（`a + b`）または*プレフィックス記法*（`+ a`）で演算子を使うことができます。インフィックス演算子は常に2つの引数を受け取り、プレフィックス演算子は常に1つの引数を受け取ります。(`a @ @ b` は `(a) @ (@b)` という意味なのか、`(a@) @ (b)` という意味なのか、曖昧になってしまうので、後置演算子は使えません。Nim には後置演算子がないので、常に `(a) @ (@b)` を意味します)。

`and`, `or`, `not` などのいくつかの組み込みキーワード演算子を除いて、演算子は常にこれらの文字で構成されます。: `+  -  *  \  /  <  >  =  @  $  ~  &  %  !  ?  ^  .  |`

ユーザー定義の演算子も可能です。独自の `@!?+~` 演算子を定義することを妨げるものではありませんが、そうすると可読性が低下する可能性があります。

演算子の優先順位は、その最初の文字によって決まります。詳細は[マニュアルに記載](manual.html#syntax-precedence)されています。

新しい演算子を定義するには、演算子をバックスティック"`"で囲みます。

``` nim
proc `$` (x: myDataType): string = ...
# これで、$演算子はmyDataTypeでも動作するようになり、解決をオーバーロードします。
# 以前のように組み込み型でも$が動作するようにします。
```

また、"`"表記は、他のプロシージャと同様に、オペレータを呼び出すのにも使用できます。

```Nim
if `==`( `+`(3, 4), 7): echo "true"
```

### 前方宣言

すべての変数、プロシージャなどは、使用する前に宣言する必要があります。(その理由は、Nimのようにメタプログラミングを幅広くサポートしている言語では、この必要性を回避することは自明ではないからです)。ただし、相互に再帰的な手続きについてはこれを行うことができません。

``` nim
# フォワード宣言。
proc even(n: int): bool
```

``` nim
proc odd(n: int): bool =
  assert(n >= 0) # 負の再帰に陥らないようにするために
  if n == 0: false
  else:
    n == 1 or even(n-1)

proc even(n: int): bool =
  assert(n >= 0) # 負の再帰に陥らないようにするために
  if n == 1: false
  else:
    n == 0 or odd(n-1)
```

ここでは、`odd` は `even` に依存し、その逆もまた然りです。したがって、`even`は完全に定義される前にコンパイラに導入される必要があります。このような前方宣言の構文は単純で、`=`とプロシージャの本体を省略するだけです。この `assert` は境界条件を追加するだけで、後に [Modules](#モジュール) のセクションで説明します。

後のバージョンの言語では、前方宣言の要件が緩和される予定です。

また、この例では、プロシージャのボディが1つの式で構成され、その値が暗黙的に返されることも示しています。

## イテレータ

簡単な数え方の例に戻りましょう。

```Nim
echo "Counting to ten: "
for i in countup(1, 10):
  echo i
```

このループをサポートする[countup](system.html#countup.i,T,T,Positive)プロックを書くことはできるでしょうか？試してみましょう。

``` nim
proc countup(a, b: int): int =
  var res = a
  while res <= b:
    return res
    inc(res)
```

しかし、これではうまくいきません。問題は、このプロシージャは単に`return`するだけではなく、反復処理が終了した後にリターンと**continue**をしなければならないことです。この *return and continue* を `yield` 文と呼びます。さて、あとは `proc` キーワードを `iterator` に置き換えるだけですが、最初のイテレータができました。

```Nim
iterator countup(a, b: int): int =
  var res = a
  while res <= b:
    yield res
    inc(res)
```

イテレータはプロシージャとよく似ていますが、いくつかの重要な違いがあります。

- イテレータは for ループからのみ呼び出すことができます。
- イテレータは `return` ステートメントを含むことができません (プロシージャは `yield` ステートメントを含むことができません)。
- イテレータには暗黙の変数 `result` はありません。
- イテレータは再帰をサポートしません。
- コンパイラはイテレータをインライン化できなければならないので、イテレータは前方宣言できません。(この制限は、コンパイラの将来のバージョンではなくなる予定です)。

しかし、クロージャ・イテレータを使って、別の制限を受けることもできます。詳細は [first-class iterators](manual.html#iterators-and-the-for-statement-firstminusclass-iterators)を参照してください。イテレータは基本的に独自の名前空間を持っているので、procと同じ名前とパラメータを持つことができます。したがって、[strutils module](strutils.html)の `split` のように、イテレータの結果を蓄積してシーケンスとして返す同名のプロックでイテレータをラップするのが一般的です。

## 基本的な型

このセクションでは、基本的な組み込み型と、その型で利用できる操作について詳しく説明します。

### ブール

Nimのブール型は`bool`と呼ばれ、あらかじめ定義された2つの値`true`と`false`で構成されています。while, if, elif, when 文の条件は bool 型でなければなりません。

bool型には，演算子 `not, and, or, xor, <, <=, >, >=, !=, ==` が定義されている。`and`と`or`の演算子は，短絡的な評価を行います．例えば，以下のようになります．

``` nim
while p != nil and p.name != "xyz":
  # p.nameは、p == nilの場合、評価されません。
  p = p.next
```

### 文字

*文字の型*を`char`といいます。そのサイズは常に1バイトなので、ほとんどのUTF-8文字を表すことはできませんが、マルチバイトのUTF-8文字を構成するバイトの1つを表すことは*できます*。その理由は、効率性にあります。圧倒的に多くのユースケースでは、UTF-8が特別に設計されているため、生成されるプログラムはUTF-8を適切に処理します。文字リテラルはシングルクォートで囲まれています。

文字は `==`, `<`, `<=`, `>`, `>=` 演算子で比較することができます。`$` 演算子は `char` を `string` に変換します。charは整数と混ぜることはできません。`char`の序数を得るには、`ord`演算子を使用してください。整数から `char` への変換は `chr` という演算子で行います。

### 文字列

文字列変数は **変更可能** なので、文字列に追加することが可能で、非常に効率的です。Nim の文字列はゼロ終端で、長さを表すフィールドを持っています。文字列の長さは組み込みの `len` 手続きで取得できます。長さは終端のゼロを数えません。終端ゼロへのアクセスはエラーになりますが、これは Nim の文字列をコピーせずに `cstring` に変換できるように存在しているだけです。

文字列の代入演算子は、文字列をコピーします。文字列を連結するには `&` 演算子を、文字列に追加するには `add` 演算子を使用します。

文字列の比較は辞書順に行われます。すべての比較演算子がサポートされています。規約では、すべての文字列はUTF-8でエンコードされますが、これは強制されません。例えば，バイナリファイルから文字列を読み込む場合，文字列は単なるバイト列である。インデックス操作 `s[i]` は，`s` の i 番目の *char* を意味し，i 番目の *unichar* を意味するわけではない。

文字列変数は空の文字列 `""` で初期化されます。

### 整数

Nimには以下のような整数型が組み込まれています。
`int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64`.

デフォルトの整数型は `int` です。整数リテラルには *type サフィックス* を付けて、デフォルトではない整数型を指定することができます。

```Nim
let
  x = 0     # x is of type `int`
  y = 0'i8  # y is of type `int8`
  z = 0'i32 # z is of type `int32`
  u = 0'u   # u is of type `uint`
```

ほとんどの場合，整数はメモリ上に存在するオブジェクトを数えるために使われるので，`int`はポインタと同じサイズになります．

一般的な演算子である `+ - * div mod < <= == != > >=` は整数に対して定義されています。演算子 `and or xor not` も整数用に定義されており，*ビット単位*の演算を行います．左へのビットシフトは `shl` 演算子で、右へのビットシフトは `shr` 演算子で行います。ビットシフト演算子は、常にその引数を *unsigned* として扱います。`算術ビットシフト`には、通常の乗算や除算を用いることができます。

符号なしの演算はすべて折り返し、オーバーフローやアンダーフローのエラーにはなりません。

異なる種類の整数型が使われている式では、ロスレスな `自動型変換` が行われます。ただし、型変換によって情報が失われるような場合には、`RangeDefect`:idx: が発生します（コンパイル時にエラーが検出できない場合）。

### Floats

Nim has these floating-point types built-in: `float float32 float64`.

The default float type is `float`. In the current implementation,
`float` is always 64-bits.

Float literals can have a *type suffix* to specify a non-default float
type:

``` {.nim test="\"nim c $1\""}
```

> var
>
> :   x = 0.0 \# x is of type `float` y = 0.0\'f32 \# y is of type
>     `float32` z = 0.0\'f64 \# z is of type `float64`

The common operators `+ - * /  <  <=  ==  !=  >  >=` are defined for
floats and follow the IEEE-754 standard.

Automatic type conversion in expressions with different kinds of
floating-point types is performed: the smaller type is converted to the
larger. Integer types are **not** converted to floating-point types
automatically, nor vice versa. Use the [toInt](system.html#toInt,float)
and [toFloat](system.html#toFloat,int) procs for these conversions.

### Type Conversion

Conversion between numerical types is performed by using the type as a
function:

``` {.nim test="\"nim c $1\""}
```

> var
>
> :   x: int32 = 1.int32 \# same as calling int32(1) y: int8 =
>     int8(\'a\') \# \'a\' == 97\'i8 z: float = 2.5 \# int(2.5) rounds
>     down to 2 sum: int = int(x) + int(y) + int(z) \# sum == 100

## Internal type representation

As mentioned earlier, the built-in [\$](dollars.html) (stringify)
operator turns any basic type into a string, which you can then print to
the console using the `echo` proc. However, advanced types, and your own
custom types, won\'t work with the `$` operator until you define it for
them. Sometimes you just want to debug the current value of a complex
type without having to write its `$` operator. You can use then the
[repr](system.html#repr,T) proc which works with any type and even
complex data graphs with cycles. The following example shows that even
for basic types there is a difference between the `$` and `repr`
outputs:

``` {.nim test="\"nim c $1\""}
```

> var
>
> :   myBool = true myCharacter = \'n\' myString = \"nim\" myInteger =
>     42 myFloat = 3.14
>
> echo myBool, \":\", repr(myBool) \# \--\> true:true echo myCharacter,
> \":\", repr(myCharacter) \# \--\> n:\'n\' echo myString, \":\",
> repr(myString) \# \--\> nim:0x10fa8c050\"nim\" echo myInteger, \":\",
> repr(myInteger) \# \--\> 42:42 echo myFloat, \":\", repr(myFloat) \#
> \--\> 3.14:3.14

## Advanced types

In Nim new types can be defined within a `type` statement:

``` {.nim test="\"nim c $1\""}
```

> type
>
> :   biggestInt = int64 \# biggest integer type that is available
>     biggestFloat = float64 \# biggest float type that is available

Enumeration and object types may only be defined within a `type`
statement.

### Enumerations

A variable of an enumeration type can only be assigned one of the
enumeration's specified values. These values are a set of ordered
symbols. Each symbol is mapped to an integer value internally. The first
symbol is represented at runtime by 0, the second by 1, and so on. For
example:

``` {.nim test="\"nim c $1\""}
type
  Direction = enum
    north, east, south, west

var x = south     # `x` is of type `Direction`; its value is `south`
echo x            # prints "south"
```

All the comparison operators can be used with enumeration types.

An enumeration's symbol can be qualified to avoid ambiguities:
`Direction.south`.

The `$` operator can convert any enumeration value to its name, and the
`ord` proc can convert it to its underlying integer value.

For better interfacing to other programming languages, the symbols of
enum types can be assigned an explicit ordinal value. However, the
ordinal values must be in ascending order.

### Ordinal types

Enumerations, integer types, `char` and `bool` (and subranges) are
called ordinal types. Ordinal types have quite a few special operations:

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--Operation
Comment \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--`ord(x)`
returns the integer value that is used to represent `x`'s value
`inc(x)` increments `x` by one `inc(x, n)` increments `x` by `n`; `n` is
an integer `dec(x)` decrements `x` by one `dec(x, n)` decrements `x` by
`n`; `n` is an integer `succ(x)` returns the successor of `x`
`succ(x, n)` returns the `n`\'th successor of `x` `pred(x)` returns the
predecessor of `x` `pred(x, n)` returns the `n`\'th predecessor of `x`
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

The [inc](system.html#inc,T,int), [dec](system.html#dec,T,int),
[succ](system.html#succ,T,int) and [pred](system.html#pred,T,int)
operations can fail by raising an `RangeDefect` or `OverflowDefect`. (If
the code has been compiled with the proper runtime checks turned on.)

### Subranges

A subrange type is a range of values from an integer or enumeration type
(the base type). Example:

``` {.nim test="\"nim c $1\""}
```

> type
>
> :   MySubrange = range\[0..5\]

`MySubrange` is a subrange of `int` which can only hold the values 0 to
5. Assigning any other value to a variable of type `MySubrange` is a
compile-time or runtime error. Assignments from the base type to one of
its subrange types (and vice versa) are allowed.

The `system` module defines the important [Natural](system.html#Natural)
type as `range[0..high(int)]` ([high](system.html#high,typedesc%5BT%5D)
returns the maximal value). Other programming languages may suggest the
use of unsigned integers for natural numbers. This is often **unwise**:
you don\'t want unsigned arithmetic (which wraps around) just because
the numbers cannot be negative. Nim's `Natural` type helps to avoid
this common programming error.

### Sets

### Arrays

An array is a simple fixed-length container. Each element in an array
has the same type. The array's index type can be any ordinal type.

Arrays can be constructed using \`\[\]\`:

``` {.nim test="\"nim c $1\""}
type
  IntArray = array[0..5, int] # an array that is indexed with 0..5
var
  x: IntArray
x = [1, 2, 3, 4, 5, 6]
for i in low(x) .. high(x):
  echo x[i]
```

The notation `x[i]` is used to access the i-th element of `x`. Array
access is always bounds checked (at compile-time or at runtime). These
checks can be disabled via pragmas or invoking the compiler with the
`--bound_checks:off` command line switch.

Arrays are value types, like any other Nim type. The assignment operator
copies the whole array contents.

The built-in [len](system.html#len,TOpenArray) proc returns the array's
length. [low(a)](system.html#low,openArray%5BT%5D) returns the lowest
valid index for the array `a` and
[high(a)](system.html#high,openArray%5BT%5D) the highest valid index.

``` {.nim test="\"nim c $1\""}
```

> type
>
> :   
>
>     Direction = enum
>
>     :   north, east, south, west
>
>     BlinkLights = enum
>
>     :   off, on, slowBlink, mediumBlink, fastBlink
>
>     LevelSetting = array\[north..west, BlinkLights\]
>
> var
>
> :   level: LevelSetting
>
> level\[north\] = on level\[south\] = slowBlink level\[east\] =
> fastBlink echo level \# \--\> \[on, fastBlink, slowBlink, off\] echo
> low(level) \# \--\> north echo len(level) \# \--\> 4 echo high(level)
> \# \--\> west

The syntax for nested arrays (multidimensional) in other languages is a
matter of appending more brackets because usually each dimension is
restricted to the same index type as the others. In Nim you can have
different dimensions with different index types, so the nesting syntax
is slightly different. Building on the previous example where a level is
defined as an array of enums indexed by yet another enum, we can add the
following lines to add a light tower type subdivided into height levels
accessed through their integer index:

``` nim
type
LightTower = array[1..10, LevelSetting]
var
tower: LightTower
tower[1][north] = slowBlink
tower[1][east] = mediumBlink
echo len(tower)     # --> 10
echo len(tower[1])  # --> 4
echo tower          # --> [[slowBlink, mediumBlink, ...more output..
# The following lines don't compile due to type mismatch errors
#tower[north][east] = on
#tower[0][1] = on
```

Note how the built-in `len` proc returns only the array's first
dimension length. Another way of defining the `LightTower` to better
illustrate its nested nature would be to omit the previous definition of
the `LevelSetting` type and instead write it embedded directly as the
type of the first dimension:

``` nim
type
LightTower = array[1..10, array[north..west, BlinkLights]]
```

It is quite common to have arrays start at zero, so there's a shortcut
syntax to specify a range from zero to the specified index minus one:

``` {.nim test="\"nim c $1\""}
```

> type
>
> :   IntArray = array\[0..5, int\] \# an array that is indexed with
>     0..5 QuickArray = array\[6, int\] \# an array that is indexed with
>     0..5
>
> var
>
> :   x: IntArray y: QuickArray
>
> x = \[1, 2, 3, 4, 5, 6\] y = x for i in low(x) .. high(x): echo
> x\[i\], y\[i\]

### Sequences

Sequences are similar to arrays but of dynamic length which may change
during runtime (like strings). Since sequences are resizable they are
always allocated on the heap and garbage collected.

Sequences are always indexed with an `int` starting at position 0. The
[len](system.html#len,seq%5BT%5D),
[low](system.html#low,openArray%5BT%5D) and
[high](system.html#high,openArray%5BT%5D) operations are available for
sequences too. The notation `x[i]` can be used to access the i-th
element of `x`.

Sequences can be constructed by the array constructor `[]` in
conjunction with the array to sequence operator `@`. Another way to
allocate space for a sequence is to call the built-in
[newSeq](system.html#newSeq) procedure.

A sequence may be passed to an openarray parameter.

Example:

``` {.nim test="\"nim c $1\""}
var
  x: seq[int] # a reference to a sequence of integers
x = @[1, 2, 3, 4, 5, 6] # the @ turns the array into a sequence allocated on the heap
```

Sequence variables are initialized with `@[]`.

The `for` statement can be used with one or two variables when used with
a sequence. When you use the one variable form, the variable will hold
the value provided by the sequence. The `for` statement is looping over
the results from the [items()](iterators.html#items.i,seq%5BT%5D)
iterator from the [system](system.html) module. But if you use the
two-variable form, the first variable will hold the index position and
the second variable will hold the value. Here the `for` statement is
looping over the results from the
[pairs()](iterators.html#pairs.i,seq%5BT%5D) iterator from the
[system](system.html) module. Examples:

``` {.nim test="\"nim c $1\""}
```

> for value in @\[3, 4, 5\]:
>
> :   echo value
>
> \# \--\> 3 \# \--\> 4 \# \--\> 5
>
> for i, value in @\[3, 4, 5\]:
>
> :   echo \"index: \", \$i, \", value:\", \$value
>
> \# \--\> index: 0, value:3 \# \--\> index: 1, value:4 \# \--\> index:
> 2, value:5

### Open arrays

**Note**: Openarrays can only be used for parameters.

Often fixed-size arrays turn out to be too inflexible; procedures should
be able to deal with arrays of different sizes. The
`openarray`{.interpreted-text role="idx"} type allows this. Openarrays
are always indexed with an `int` starting at position 0. The
[len](system.html#len,TOpenArray),
[low](system.html#low,openArray%5BT%5D) and
[high](system.html#high,openArray%5BT%5D) operations are available for
open arrays too. Any array with a compatible base type can be passed to
an openarray parameter, the index type does not matter.

``` {.nim test="\"nim c $1\""}
```

> var
>
> :   fruits: seq\[string\] \# reference to a sequence of strings that
>     is initialized with \'@\[\]\' capitals: array\[3, string\] \#
>     array of strings with a fixed size
>
> capitals = \[\"New York\", \"London\", \"Berlin\"\] \# array
> \'capitals\' allows assignment of only three elements
> fruits.add(\"Banana\") \# sequence \'fruits\' is dynamically
> expandable during runtime fruits.add(\"Mango\")
>
> proc openArraySize(oa: openArray\[string\]): int =
>
> :   oa.len
>
> assert openArraySize(fruits) == 2 \# procedure accepts a sequence as
> parameter assert openArraySize(capitals) == 3 \# but also an array
> type

The openarray type cannot be nested: multidimensional openarrays are not
supported because this is seldom needed and cannot be done efficiently.

### Varargs

A `varargs` parameter is like an openarray parameter. However, it is
also a means to implement passing a variable number of arguments to a
procedure. The compiler converts the list of arguments to an array
automatically:

``` {.nim test="\"nim c $1\""}
```

> proc myWriteln(f: File, a: varargs\[string\]) =
>
> :   
>
>     for s in items(a):
>
>     :   write(f, s)
>
>     write(f, \"n\")
>
> myWriteln(stdout, \"abc\", \"def\", \"xyz\") \# is transformed by the
> compiler to: myWriteln(stdout, \[\"abc\", \"def\", \"xyz\"\])

This transformation is only done if the varargs parameter is the last
parameter in the procedure header. It is also possible to perform type
conversions in this context:

``` {.nim test="\"nim c $1\""}
```

> proc myWriteln(f: File, a: varargs\[string, `$`\]) =
>
> :   
>
>     for s in items(a):
>
>     :   write(f, s)
>
>     write(f, \"n\")
>
> myWriteln(stdout, 123, \"abc\", 4.0) \# is transformed by the compiler
> to: myWriteln(stdout, \[\$123, \$\"abc\", \$4.0\])

In this example [\$](dollars.html) is applied to any argument that is
passed to the parameter `a`. Note that [\$](dollars.html) applied to
strings is a nop.

### Slices

Slices look similar to subranges types in syntax but are used in a
different context. A slice is just an object of type Slice which
contains two bounds, `a` and `b`. By itself a slice is not very useful,
but other collection types define operators which accept Slice objects
to define ranges.

``` {.nim test="\"nim c $1\""}
var
  a = "Nim is a programming language"
  b = "Slices are useless."

echo a[7 .. 12] # --> 'a prog'
b[11 .. ^2] = "useful"
echo b # --> 'Slices are useful.'
```

In the previous example slices are used to modify a part of a string.
The slice's bounds can hold any value supported by their type, but it
is the proc using the slice object which defines what values are
accepted.

To understand some of the different ways of specifying the indices of
strings, arrays, sequences, etc., it must be remembered that Nim uses
zero-based indices.

So the string `b` is of length 19, and two different ways of specifying
the indices are

``` nim
"Slices are useless."
 |          |     |
 0         11    17   using indices
^19        ^8    ^2   using ^ syntax
```

where `b[0 .. ^1]` is equivalent to `b[0 .. b.len-1]` and
`b[0 ..< b.len]`, and it can be seen that the `^1` provides a short-hand
way of specifying the `b.len-1`. See the [backwards index
operator](system.html#%5E.t%2Cint).

In the above example, because the string ends in a period, to get the
portion of the string that is \"useless\" and replace it with
\"useful\".

`b[11 .. ^2]` is the portion \"useless\", and `b[11 .. ^2] = "useful"`
replaces the \"useless\" portion with \"useful\", giving the result
\"Slices are useful.\"

Note 1: alternate ways of writing this are `b[^8 .. ^2] = "useful"` or
as `b[11 .. b.len-2] = "useful"` or as `b[11 ..< b.len-1] = "useful"`.

Note 2: As the `^` template returns a [distinct
int](manual.html#types-distinct-type) of type `BackwardsIndex`, we can
have a `lastIndex` constant defined as `const lastIndex = ^1`, and later
used as `b[0 .. lastIndex]`.

### Objects

The default type to pack different values together in a single structure
with a name is the object type. An object is a value type, which means
that when an object is assigned to a new variable all its components are
copied as well.

Each object type `Foo` has a constructor `Foo(field: value, ...)` where
all of its fields can be initialized. Unspecified fields will get their
default value.

``` nim
type
Person = object
name: string
age: int
var person1 = Person(name: "Peter", age: 30)

echo person1.name # "Peter"
echo person1.age  # 30

var person2 = person1 # copy of person 1

person2.age += 14

echo person1.age # 30
echo person2.age # 44


# the order may be changed
let person3 = Person(age: 12, name: "Quentin")

# not every member needs to be specified
let person4 = Person(age: 3)
# unspecified members will be initialized with their default
# values. In this case it is the empty string.
doAssert person4.name == ""
```

Object fields that should be visible from outside the defining module
have to be marked with `*`.

``` {.nim test="\"nim c $1\""}
type
  Person* = object # the type is visible from other modules
    name*: string  # the field of this type is visible from other modules
    age*: int
```

### Tuples

Tuples are very much like what you have seen so far from objects. They
are value types where the assignment operator copies each component.
Unlike object types though, tuple types are structurally typed, meaning
different tuple-types are *equivalent* if they specify fields of the
same type and of the same name in the same order.

The constructor `()` can be used to construct tuples. The order of the
fields in the constructor must match the order in the tuple's
definition. But unlike objects, a name for the tuple type may not be
used here.

Like the object type the notation `t.field` is used to access a tuple's
field. Another notation that is not available for objects is `t[i]` to
access the `i`\'th field. Here `i` must be a constant integer.

``` {.nim test="\"nim c $1\""}
```

> type
>
> :   \# type representing a person: \# A person consists of a name and
>     an age. Person = tuple name: string age: int
>
>     \# Alternative syntax for an equivalent type. PersonX =
>     tuple\[name: string, age: int\]
>
>     \# anonymous field syntax PersonY = (string, int)
>
> var
>
> :   person: Person personX: PersonX personY: PersonY
>
> person = (name: \"Peter\", age: 30) \# Person and PersonX are
> equivalent personX = person
>
> \# Create a tuple with anonymous fields: personY = (\"Peter\", 30)
>
> \# A tuple with anonymous fields is compatible with a tuple that has
> \# field names. person = personY personY = person
>
> \# Usually used for short tuple initialization syntax person =
> (\"Peter\", 30)
>
> echo person.name \# \"Peter\" echo person.age \# 30
>
> echo person\[0\] \# \"Peter\" echo person\[1\] \# 30
>
> \# You don\'t need to declare tuples in a separate type section. var
> building: tuple\[street: string, number: int\] building = (\"Rue del
> Percebe\", 13) echo building.street
>
> \# The following line does not compile, they are different tuples!
> #person = building \# \--\> Error: type mismatch: got (tuple\[street:
> string, number: int\]) \# but expected \'Person\'

Even though you don\'t need to declare a type for a tuple to use it,
tuples created with different field names will be considered different
objects despite having the same field types.

Tuples can be *unpacked* during variable assignment. This can be handy
to assign directly the fields of the tuples to individually named
variables. An example of this is the
[splitFile](os.html#splitFile,string) proc from the [os module](os.html)
which returns the directory, name, and extension of a path at the same
time. For tuple unpacking to work you must use parentheses around the
values you want to assign the unpacking to, otherwise, you will be
assigning the same value to all the individual variables! For example:

``` {.nim test="\"nim c $1\""}
import std/os

let
  path = "usr/local/nimc.html"
  (dir, name, ext) = splitFile(path)
  baddir, badname, badext = splitFile(path)
echo dir      # outputs "usr/local"
echo name     # outputs "nimc"
echo ext      # outputs ".html"
# All the following output the same line:
# "(dir: usr/local, name: nimc, ext: .html)"
echo baddir
echo badname
echo badext
```

Tuple unpacking is also supported in for-loops:

``` {.nim test="\"nim c $1\""}
```

> let a = \[(10, \'a\'), (20, \'b\'), (30, \'c\')\]
>
> for (x, c) in a:
>
> :   echo x
>
> \# This will output: 10; 20; 30
>
> \# Accessing the index is also possible: for i, (x, c) in a: echo i, c
> \# This will output: 0a; 1b; 2c

Fields of tuples are always public, they don\'t need to be explicity
marked to be exported, unlike for example fields in an object type.

### Reference and pointer types

References (similar to pointers in other programming languages) are a
way to introduce many-to-one relationships. This means different
references can point to and modify the same location in memory.

Nim distinguishes between `traced`{.interpreted-text role="idx"} and
`untraced`{.interpreted-text role="idx"} references. Untraced references
are also called *pointers*. Traced references point to objects in a
garbage-collected heap, untraced references point to manually allocated
objects or objects elsewhere in memory. Thus untraced references are
*unsafe*. However, for certain low-level operations (e.g. accessing the
hardware), untraced references are necessary.

Traced references are declared with the **ref** keyword; untraced
references are declared with the **ptr** keyword.

The empty `[]` subscript notation can be used to *de-refer* a reference,
meaning to retrieve the item the reference points to. The `.` (access a
tuple/object field operator) and `[]` (array/string/sequence index
operator) operators perform implicit dereferencing operations for
reference types:

``` {.nim test="\"nim c $1\""}
type
  Node = ref object
    le, ri: Node
    data: int

var n = Node(data: 9)
echo n.data
# no need to write n[].data; in fact n[].data is highly discouraged!
```

To allocate a new traced object, the built-in procedure `new` can be
used:

``` nim
var n: Node
new(n)
```

To deal with untraced memory, the procedures `alloc`, `dealloc` and
`realloc` can be used. The [system](system.html) module's documentation
contains further details.

If a reference points to *nothing*, it has the value `nil`.

### Procedural type

A procedural type is a (somewhat abstract) pointer to a procedure. `nil`
is an allowed value for a variable of a procedural type. Nim uses
procedural types to achieve `functional`{.interpreted-text role="idx"}
programming techniques.

Example:

``` {.nim test="\"nim c $1\""}
```

> proc greet(name: string): string =
>
> :   \"Hello, \" & name & \"!\"
>
> proc bye(name: string): string =
>
> :   \"Goodbye, \" & name & \".\"
>
> proc communicate(greeting: proc (x: string): string, name: string) =
>
> :   echo greeting(name)
>
> communicate(greet, \"John\") communicate(bye, \"Mary\")

A subtle issue with procedural types is that the calling convention of
the procedure influences the type compatibility: procedural types are
only compatible if they have the same calling convention. The different
calling conventions are listed in the
[manual](manual.html#types-procedural-type).

### Distinct type

A Distinct type allows for the creation of a new type that \"does not
imply a subtype relationship between it and its base type\". You must
**explicitly** define all behavior for the distinct type. To help with
this, both the distinct type and its base type can cast from one type to
the other. Examples are provided in the
[manual](manual.html#types-distinct-type).

## Modules

Nim supports splitting a program into pieces with a *module* concept.
Each module is in its own file. Modules enable
`information hiding`{.interpreted-text role="idx"} and
`separate compilation`{.interpreted-text role="idx"}. A module may gain
access to the symbols of another module by using the
`import`{.interpreted-text role="idx"} statement. Only top-level symbols
that are marked with an asterisk (`*`) are exported:

``` nim
# Module A
var
x*, y: int
proc `*` *(a, b: seq[int]): seq[int] =
  # allocate a new sequence:
  newSeq(result, len(a))
  # multiply two int sequences:
  for i in 0 ..< len(a): result[i] = a[i] * b[i]

when isMainModule:
  # test the new `*` operator for sequences:
  assert(@[1, 2, 3] * @[1, 2, 3] == @[1, 4, 9])
```

The above module exports `x` and `*`, but not `y`.

A module's top-level statements are executed at the start of the
program. This can be used to initialize complex data structures for
example.

Each module has a special magic constant `isMainModule` that is true if
the module is compiled as the main file. This is very useful to embed
tests within the module as shown by the above example.

A symbol of a module *can* be *qualified* with the `module.symbol`
syntax. And if a symbol is ambiguous, it *must* be qualified. A symbol
is ambiguous if it is defined in two (or more) different modules and
both modules are imported by a third one:

``` nim
# Module A
var x*: string
```

``` nim
# Module B
var x*: int
```

``` nim
# Module C
import A, B
write(stdout, x) # error: x is ambiguous
write(stdout, A.x) # okay: qualifier used
var x = 4
write(stdout, x) # not ambiguous: uses the module C's x
```

But this rule does not apply to procedures or iterators. Here the
overloading rules apply:

``` nim
# Module A
proc x*(a: int): string = $a
```

``` nim
# Module B
proc x*(a: string): string = $a
```

``` nim
# Module C
import A, B
write(stdout, x(3))   # no error: A.x is called
write(stdout, x(""))  # no error: B.x is called
proc x*(a: int): string = discard
write(stdout, x(3))   # ambiguous: which `x` is to call?
```

### Excluding symbols

The normal `import` statement will bring in all exported symbols. These
can be limited by naming symbols that should be excluded using the
`except` qualifier.

``` nim
import mymodule except y
```

### From statement

We have already seen the simple `import` statement that just imports all
exported symbols. An alternative that only imports listed symbols is the
`from import` statement:

``` nim
from mymodule import x, y, z
```

The `from` statement can also force namespace qualification on symbols,
thereby making symbols available, but needing to be qualified in order
to be used.

``` nim
from mymodule import x, y, z
x()           # use x without any qualification
```

``` nim
from mymodule import nil
mymodule.x()  # must qualify x with the module name as prefix

x()           # using x here without qualification is a compile error
```

Since module names are generally long to be descriptive, you can also
define a shorter alias to use when qualifying symbols.

``` nim
from mymodule as m import nil
m.x()         # m is aliasing mymodule
```

### Include statement

The `include` statement does something fundamentally different than
importing a module: it merely includes the contents of a file. The
`include` statement is useful to split up a large module into several
files:

``` nim
include fileA, fileB, fileC
```

## Part 2

So, now that we are done with the basics, let's see what Nim offers
apart from a nice syntax for procedural programming: [Part
II](tut2.html)
