■ http://clojure.org/rationale
Rationale	→	正当性
Customers and stakeholders have substantial investments in, and are comfortable with the performance, security and stability of, industry-standard platforms like the JVM.	→	顧客と投資家は相当な投資を呼んで、パフォーマンスに対して不安がありません、保安、そして、安定性、業界標準プラットホームはJVMに合います。
While Java developers may envy the succinctness, flexibility and productivity of dynamic languages, they have concerns about running on customer-approved infrastructure, access to their existing code base and libraries, and performance.In addition, they face ongoing problems dealing with concurrency using native threads and locking.	→	Java開発者がダイナミックな言語の簡潔さ、柔軟性と生産性をねたむかもしれない間、彼らには顧客認可の基盤のランニング、既存のコード・ベースとライブラリへのアクセスとパフォーマンスに対する懸念があります。
Clojure is an effort in pragmatic dynamic language design in this context.	→	Clojureは、この文脈における実際的なダイナミックな言語設計の努力です。
It endeavors to be a general-purpose language suitable in those areas where Java is suitable.	→	Javaが適当であるそれらの地域で適当な多目的言語であろうと、それは努力します。
It reflects the reality that, for the concurrent programming future, pervasive, unmoderated mutation simply has to go.	→	コンカレント・プログラミング将来のために、全面的な、軽減されていない突然変異が単に行かなければならないことは、現実を反映します。
Clojure meets its goals by:	→	Clojureは、以下によってそのゴールに対処します：
embracing an industry-standard, open platform - the JVM;	→	業界標準（開いたプラットホーム）を受け入れること－JVM;
modernizing a venerable language - Lisp;	→	尊敬に値する言語を現代化すること－LISP;
fostering functional programming with immutable persistent data structures;	→	不変の持続的なデータ構造で関数型プログラミングを促進すること;
and providing built-in concurrency support via software transactional memory and asynchronous agents.	→	そして、ソフトウェア処理の記憶と非同期エージェントによってビルトイン並列性支持を提供すること。
The result is robust, practical, and fast.	→	結果は強くて、実際的で、速いです。
Clojure has a distinctive approach to state and identity.	→	Clojureは、州とアイデンティティへの特徴的なアプローチをします。
Why Clojure?	→	理由Clojure？
Why did I write yet another programming language? Basically because I wanted:	→	なぜ、私はさらにもう一つのプログラミング言語を書きましたか？
A Lispfor Functional Programmingsymbiotic with an established Platformdesigned for Concurrencyand couldn't find one.	→	基本的に私が以下が欲しかったので：
Here's an outline of some of the motivating ideas behind Clojure.	→	確立したPlatformで共生Functional ProgrammingのためのLISPは、Concurrencyのために設計して、1を見つけることができませんでした。
Lisp is a good thingOften emulated / pillaged, still not duplicatedLambda calculus yields an extremely small coreAlmost no syntaxCore advantage still code-as-data and syntactic abstractionWhat about the standard Lisps (Common Lisp and Scheme)?	→	Clojureの後の動機づけしている考えのいくつかの輪郭は、ここにあります。
Slow / no innovation post standardizationCore data structures mutable, not extensibleNo concurrency in specsGood implementations already exist for JVM (ABCL, Kawa, SISC et al)Standard Lisps are their own platformsClojure is a Lisp not constrained by backwards compatibilityExtends the code-as-data paradigm to maps and vectorsDefaults to immutabilityCore data structures are extensible abstractionsEmbraces a platform (JVM)Functional programming is a good thingImmutable data + first-class functionsCould always be done in Lisp, by discipline / conventionBut if a data structure can be mutated, dangerous to presume it won't beIn traditional Lisp, only the list data structure is structurally recursivePure functional languages tend to strongly static typesNot for everyone, or every taskClojure is a functional language with a dynamic emphasisAll data structures immutable & persistent, supporting recursionHeterogeneous collections, return typesDynamic polymorphism	→	LISPは、Oftenが模倣して/略奪したよいことです、にもかかわらず、複製されたLambda微積分学は、標準的なLisps（コモンLISPとScheme）のまわりに、データとしてのとても小さな中心的なAlmostなし構文Core優位性スチール・コードと統語的な抽象概念Whatを与えません？
→	ゆっくり/少しもでなく、革新は標準化に変わりやすいCoreデータ構造を郵送します、スペックで伸長可能なNo並列性よくやった、実施がすでに存在します、スタンダードLispsがそうであるJVM（ABCL、カワ、SISCほか）のために、彼ら自身のプラットホームClojureは地図に下位互換性Extendsデータとしてのコード・パラダイムによって束縛されないLISPです、そして、不変Coreデータ構造へのベクトルDefaultsは伸長可能な抽象概念Embracesプラットホームです∥（JVM）、FunctionalプログラミングはImmutableなデータ+が一等で機能するという利益ことです。そして、Couldは常にLISPでされます、規律/慣例によってしかしデータ構造が突然変異することができるならば、危険な思います、それは伝統的なLISPでありません、リスト・データ構造だけは関数型言語が誰のためにでも強く静的タイプNotに管理する構造的に再帰的なPureです、または、あらゆる仕事Clojureはデータが構築するダイナミックな強調Allによる関数型言語です。そして、不変でと持続的で、支える再帰HeterogeneousコレクションはタイプDynamicポリエステル繊維モルフィズムを返します

Languages and Platforms	→	言語とプラットホーム
VMs, not OSes, are the platforms of the future, providing:	→	VM（OSesでない）は将来のプラットホームです。そして、以下を提供します：
Type systemDynamic enforcement and safetyLibraries	→	タイプ・システム力施行と安全ライブラリ
Abstract away OSes	→	離れてOSesを抽出してください
Huge set of facilities	→	施設の巨大なセット
Built-in and 3rd-party	→	ビルトインで第三者の
Memory and other resource managementGC is platform, not language, facilityBytecode + JIT compilation	→	記憶と他の資源管理GCは、プラットホーム、言語でない、施設Bytecode + JIT編集です
Abstracts away hardware	→	離れてハードウェアを取ります
Language as platform vs. language + platformOld way - each language defines its own runtimeGC, bytecode, type system, libraries etcNew way (JVM,.	→	プラットホーム対言語+プラットホームOld方法として言語－各々の言語は、それ自身の実行時GC、バイトコード、タイプ・システムを定めます。そして、図書館その他が、ニュー方法である∥（JVM。
Net)Common runtime independent of languageLanguage built for platform vs language ported-to platformMany new languages still take 'Language as platform' approachWhen ported, have platform-on-platform issuesMemory management, type-system, threading issuesLibrary duplicationIf original language based on C, some extension libraries written in C don't come overPlatforms are dictated by clients'Must run on JVM' or.	→	ネットワーク）、プラットホームのために造られる言語Language対Whenが運んだ『プラットホームとしての言語』アプローチに、新しい言語がまだ持っていく言語に運ばれたプラットホームManyから独立しているコモン実行時にはプラットホームのプラットホーム問題Memory管理、タイプ-システム、Cに基づくスレッディング問題図書館重複If原語があります、Cで記述される若干の拡張ライブラリはPlatformsを襲いませんクライアントで口述します『JVMで動かなければなりません』、または。
Net vs 'must run on Unix' or WindowsJVM has established track record and trust levelNow also open sourceInterop with other code requiredC linkage insufficient these daysJava / JVM islanguage + platformNot the original story, but other languages for JVM always existed, now embraced by SunJava can be tedious, insufficiently expressiveLack of first-class functions, no type inference, etcAbility to call / consume Java is criticalClojure is the language, JVM the platformObject Orientation is overratedBorn of simulation, now used for everything, even when inappropriateEncouraged by Java / C# in all situations, due to their lack of (idiomatic) support for anything elseMutable stateful objects are the new spaghetti codeHard to understand, test, reason aboutConcurrency disasterInheritance is not the only way to do polymorphism"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.	→	正味の対『Unix上で動作されなければならない』、または、Windows JVMは確立したトラックに記録させます、そして、Java/JVM等言語+プラットホームNot原作が常に他の言語以外のJVMのために存在したこれらの日、レベルNowも不十分な他のコード必須のCつながりでソースInteropを開けると思います、現在、第一級機能の退屈な、不十分に表現力豊かなLackは、Sun Javaによって包含されることができます、推論を少しもでなくタイプします、その他呼び出しにAbility/Javaを消費します重要なClojureです言語です、JVMプラットホームObject Orientationは、現在すべてのために使われて、公平なシミュレーションの過大評価されたBornですいつの不適当なすべての状況（（慣用的な）支持の彼らの不足への与えられるべきもの）のJava/C#によってEncouragedステートフル物が新しいスパゲッティーコードHardであるMutableな他に何かのために理解します、試験して、推論しますInheritanceが唯一の方法でないConcurrency災害について「10の機能に10のデータ構造に作用させるより、100の機能に1つのデータ構造に作用させることは、よいです」というポリエステル繊維モルフィズム。
" - Alan J.PerlisClojure models its data structures as immutable objects represented by interfaces, and otherwise does not offer its own class system.	→	アラン・Ｊ・パーリスClojureはインターフェースで見受けられる不変の物としてそのデータ構造をモデル化して、さもなければそれ自身の階級制度を提供しません。
Many functions defined on few primary data structures (seq, map, vector, set).	→	ほとんど主要なデータ構造（seq、地図、ベクトル（セットされる））で定められない多くの機能。
Write Java in Java, consume and extend Java from Clojure.	→	JavaをJavaで書いて、破滅して、ClojureからJavaを広げてください。
Polymorphism is a good thingSwitch statements, structural matching etc yield brittle systemsPolymorphism yields extensible, flexible systemsClojure multimethods decouple polymorphism from OO and typesSupports multiple taxonomiesDispatches via static, dynamic or external properties, metadata, etcConcurrency and the multi-core futureImmutability makes much of the problem go awayShare freely between threadsBut changing state a reality for simulations and for in-program proxies to the outside worldLocking is too hard to get right over and over againClojure's software transactional memory and agent systems do the hard partIn short, I think Clojure occupies a unique niche as a functional Lisp for the JVM with strong concurrency support.	→	PolymorphismはSwitch声明、構造マッチングその他が伸長可能なもろいシステムPolymorphism産出高を与えるという良いことです、柔軟なシステムClojureマルチ方法は静的であるか、ダイナミックであるか、外部の所有物（メタデータ）を通してポリエステル繊維モルフィズムをOOとタイプSupportsチェーン店分類学Dispatchesから分離します。そして、その他Concurrencyとマルチコア将来Immutabilityは問題の多くを去らせます自由に糸の間でシェアしかし変わることが何度も何度もClojureのソフトウェア処理の記憶を正しくするにはあまりに、シミュレーションのための、そして、外界Lockingへのプログラムの代理のための現実が難しい、そして、薬品系が難しい役をすると述べます
Check out some of the features	→	特徴のいくらかをチェックしてください。

