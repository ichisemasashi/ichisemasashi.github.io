LISP
■ https://ja.wikipedia.org/wiki/LISP

Clojure
■ https://ja.wikipedia.org/wiki/Clojure


Clojure プログラミング言語
■ http://www.ibm.com/developerworks/jp/opensource/library/os-eclipse-clojure/

予定：https://en.wikipedia.org/wiki/Clojure
予定：https://en.wikipedia.org/wiki/Lisp_(programming_language)

■ http://clojure.org/

Clojure is a dynamic programming language that targets the Java Virtual Machine (and the CLR, and JavaScript).	→	Clojureは、Java仮想マシン（そして、CLRとJavaScript）を目標とするダイナミックなプログラミング言語です。
It is designed to be a general-purpose language, combining the approachability and interactive development of a scripting language with an efficient and robust infrastructure for multithreaded programming.	→	それは多目的言語であるように設計されています。そして、マルチスレッドのプログラミングのために近づきやすさとスクリプト言語のインタラクティブ発達を効率的で強力な基盤と結合します。
Clojure is a compiled language - it compiles directly to JVM bytecode, yet remains completely dynamic.	→	Clojureは編集された言語です－それはJVMに直接バイトコードを編集するが、完全にダイナミックなままです。
Every feature supported by Clojure is supported at runtime.	→	Clojureで支えられるあらゆる特徴は、実行時で支えられます。
Clojure provides easy access to the Java frameworks, with optional type hints and type inference, to ensure that calls to Java can avoid reflection.	→	Javaへの呼び出しが反射を避けることができることを確実とするために、Clojureは、オプションのタイプ・ヒントとタイプ推論で、簡単なアクセスをJavaフレームワークに提供します。
Clojure is a dialect of Lisp, and shares with Lisp the code-as-data philosophy and a powerful macro system.	→	ClojureはLISPの方言で、データとしてのコード哲学と強力なマクロ・システムをLISPと共有します。
Clojure is predominantly a functional programming language, and features a rich set of immutable, persistent data structures.	→	Clojureは主に関数型言語で、不変の、持続的なデータ構造の豊かなセットを特徴とします。
When mutable state is needed, Clojure offers a software transactional memory system and reactive Agent system that ensure clean, correct, multithreaded designs.	→	変わりやすい州が必要であるとき、Clojureはきれいな、正しい、マルチスレッドのデザインを確実にするソフトウェア処理のメモリ・システムと反応Agentシステムを提供します。
I hope you find Clojure's combination of facilities elegant, powerful, practical and fun to use.	→	あなたが、強力で、エレガントな施設のClojureの組合せが実際的であるとわかって、使用にふざけることを、私は望みます。
The primary forum for discussing Clojure is the Google Group - please join us!	→	Clojureを議論するための主要なフォーラムはGoogleグループです－我々に加わってください！
Rich Hickey	→	豊かなヒッキー
CTO Cognitect, providers of enterprise support for Clojure	→	CTO Cognitect、Clojureに対する企業支持の提供者。


■ http://clojure.org/rationale
Rationale	→	正当性
Customers and stakeholders have substantial investments in, and are comfortable with the performance, security and stability of, industry-standard platforms like the JVM.	→	顧客と投資家は相当な投資を呼んで、パフォーマンスに対して不安がありません、保安、そして、安定性、業界標準プラットホームはJVMに合います。
While Java developers may envy the succinctness, flexibility and productivity of dynamic languages, they have concerns about running on customer-approved infrastructure, access to their existing code base and libraries, and performance.In addition, they face ongoing problems dealing with concurrency using native threads and locking.	→	Java開発者がダイナミックな言語の簡潔さ、柔軟性と生産性をねたむかもしれない間、彼らには顧客認可の基盤のランニング、既存のコード・ベースとライブラリへのアクセスとパフォーマンスに対する懸念があります。
Clojure is an effort in pragmatic dynamic language design in this context.	→	Clojureは、この文脈における実際的なダイナミックな言語設計の努力です。
It endeavors to be a general-purpose language suitable in those areas where Java is suitable.	→	Javaが適当であるそれらの地域で適当な多目的言語であろうと、それは努力します。
It reflects the reality that, for the concurrent programming future, pervasive, unmoderated mutation simply has to go.	→	コンカレント・プログラミング将来のために、全面的な、軽減されていない突然変異が単に行かなければならないことは、現実を反映します。
Clojure meets its goals by:	→	Clojureは、以下によってそのゴールに対処します：
embracing an industry-standard, open platform - the JVM;	→	業界標準（開いたプラットホーム）を受け入れること－JVM;
modernizing a venerable language - Lisp;	→	尊敬に値する言語を現代化すること－LISP;
fostering functional programming with immutable persistent data structures;	→	不変の持続的なデータ構造で関数型プログラミングを促進すること;
and providing built-in concurrency support via software transactional memory and asynchronous agents.	→	そして、ソフトウェア処理の記憶と非同期エージェントによってビルトイン並列性支持を提供すること。
The result is robust, practical, and fast.	→	結果は強くて、実際的で、速いです。
Clojure has a distinctive approach to state and identity.	→	Clojureは、州とアイデンティティへの特徴的なアプローチをします。
Why Clojure?	→	理由Clojure？
Why did I write yet another programming language? Basically because I wanted:	→	なぜ、私はさらにもう一つのプログラミング言語を書きましたか？
A Lispfor Functional Programmingsymbiotic with an established Platformdesigned for Concurrencyand couldn't find one.	→	基本的に私が以下が欲しかったので：
Here's an outline of some of the motivating ideas behind Clojure.	→	確立したPlatformで共生Functional ProgrammingのためのLISPは、Concurrencyのために設計して、1を見つけることができませんでした。
Lisp is a good thingOften emulated / pillaged, still not duplicatedLambda calculus yields an extremely small coreAlmost no syntaxCore advantage still code-as-data and syntactic abstractionWhat about the standard Lisps (Common Lisp and Scheme)?	→	Clojureの後の動機づけしている考えのいくつかの輪郭は、ここにあります。
Slow / no innovation post standardizationCore data structures mutable, not extensibleNo concurrency in specsGood implementations already exist for JVM (ABCL, Kawa, SISC et al)Standard Lisps are their own platformsClojure is a Lisp not constrained by backwards compatibilityExtends the code-as-data paradigm to maps and vectorsDefaults to immutabilityCore data structures are extensible abstractionsEmbraces a platform (JVM)Functional programming is a good thingImmutable data + first-class functionsCould always be done in Lisp, by discipline / conventionBut if a data structure can be mutated, dangerous to presume it won't beIn traditional Lisp, only the list data structure is structurally recursivePure functional languages tend to strongly static typesNot for everyone, or every taskClojure is a functional language with a dynamic emphasisAll data structures immutable & persistent, supporting recursionHeterogeneous collections, return typesDynamic polymorphism	→	LISPは、Oftenが模倣して/略奪したよいことです、にもかかわらず、複製されたLambda微積分学は、標準的なLisps（コモンLISPとScheme）のまわりに、データとしてのとても小さな中心的なAlmostなし構文Core優位性スチール・コードと統語的な抽象概念Whatを与えません？
→	ゆっくり/少しもでなく、革新は標準化に変わりやすいCoreデータ構造を郵送します、スペックで伸長可能なNo並列性よくやった、実施がすでに存在します、スタンダードLispsがそうであるJVM（ABCL、カワ、SISCほか）のために、彼ら自身のプラットホームClojureは地図に下位互換性Extendsデータとしてのコード・パラダイムによって束縛されないLISPです、そして、不変Coreデータ構造へのベクトルDefaultsは伸長可能な抽象概念Embracesプラットホームです∥（JVM）、FunctionalプログラミングはImmutableなデータ+が一等で機能するという利益ことです。そして、Couldは常にLISPでされます、規律/慣例によってしかしデータ構造が突然変異することができるならば、危険な思います、それは伝統的なLISPでありません、リスト・データ構造だけは関数型言語が誰のためにでも強く静的タイプNotに管理する構造的に再帰的なPureです、または、あらゆる仕事Clojureはデータが構築するダイナミックな強調Allによる関数型言語です。そして、不変でと持続的で、支える再帰HeterogeneousコレクションはタイプDynamicポリエステル繊維モルフィズムを返します

Languages and Platforms	→	言語とプラットホーム
VMs, not OSes, are the platforms of the future, providing:	→	VM（OSesでない）は将来のプラットホームです。そして、以下を提供します：
Type systemDynamic enforcement and safetyLibraries	→	タイプ・システム力施行と安全ライブラリ
Abstract away OSes	→	離れてOSesを抽出してください
Huge set of facilities	→	施設の巨大なセット
Built-in and 3rd-party	→	ビルトインで第三者の
Memory and other resource managementGC is platform, not language, facilityBytecode + JIT compilation	→	記憶と他の資源管理GCは、プラットホーム、言語でない、施設Bytecode + JIT編集です
Abstracts away hardware	→	離れてハードウェアを取ります
Language as platform vs. language + platformOld way - each language defines its own runtimeGC, bytecode, type system, libraries etcNew way (JVM,.	→	プラットホーム対言語+プラットホームOld方法として言語－各々の言語は、それ自身の実行時GC、バイトコード、タイプ・システムを定めます。そして、図書館その他が、ニュー方法である∥（JVM。
Net)Common runtime independent of languageLanguage built for platform vs language ported-to platformMany new languages still take 'Language as platform' approachWhen ported, have platform-on-platform issuesMemory management, type-system, threading issuesLibrary duplicationIf original language based on C, some extension libraries written in C don't come overPlatforms are dictated by clients'Must run on JVM' or.	→	ネットワーク）、プラットホームのために造られる言語Language対Whenが運んだ『プラットホームとしての言語』アプローチに、新しい言語がまだ持っていく言語に運ばれたプラットホームManyから独立しているコモン実行時にはプラットホームのプラットホーム問題Memory管理、タイプ-システム、Cに基づくスレッディング問題図書館重複If原語があります、Cで記述される若干の拡張ライブラリはPlatformsを襲いませんクライアントで口述します『JVMで動かなければなりません』、または。
Net vs 'must run on Unix' or WindowsJVM has established track record and trust levelNow also open sourceInterop with other code requiredC linkage insufficient these daysJava / JVM islanguage + platformNot the original story, but other languages for JVM always existed, now embraced by SunJava can be tedious, insufficiently expressiveLack of first-class functions, no type inference, etcAbility to call / consume Java is criticalClojure is the language, JVM the platformObject Orientation is overratedBorn of simulation, now used for everything, even when inappropriateEncouraged by Java / C# in all situations, due to their lack of (idiomatic) support for anything elseMutable stateful objects are the new spaghetti codeHard to understand, test, reason aboutConcurrency disasterInheritance is not the only way to do polymorphism"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.	→	正味の対『Unix上で動作されなければならない』、または、Windows JVMは確立したトラックに記録させます、そして、Java/JVM等言語+プラットホームNot原作が常に他の言語以外のJVMのために存在したこれらの日、レベルNowも不十分な他のコード必須のCつながりでソースInteropを開けると思います、現在、第一級機能の退屈な、不十分に表現力豊かなLackは、Sun Javaによって包含されることができます、推論を少しもでなくタイプします、その他呼び出しにAbility/Javaを消費します重要なClojureです言語です、JVMプラットホームObject Orientationは、現在すべてのために使われて、公平なシミュレーションの過大評価されたBornですいつの不適当なすべての状況（（慣用的な）支持の彼らの不足への与えられるべきもの）のJava/C#によってEncouragedステートフル物が新しいスパゲッティーコードHardであるMutableな他に何かのために理解します、試験して、推論しますInheritanceが唯一の方法でないConcurrency災害について「10の機能に10のデータ構造に作用させるより、100の機能に1つのデータ構造に作用させることは、よいです」というポリエステル繊維モルフィズム。
" - Alan J.PerlisClojure models its data structures as immutable objects represented by interfaces, and otherwise does not offer its own class system.	→	アラン・Ｊ・パーリスClojureはインターフェースで見受けられる不変の物としてそのデータ構造をモデル化して、さもなければそれ自身の階級制度を提供しません。
Many functions defined on few primary data structures (seq, map, vector, set).	→	ほとんど主要なデータ構造（seq、地図、ベクトル（セットされる））で定められない多くの機能。
Write Java in Java, consume and extend Java from Clojure.	→	JavaをJavaで書いて、破滅して、ClojureからJavaを広げてください。
Polymorphism is a good thingSwitch statements, structural matching etc yield brittle systemsPolymorphism yields extensible, flexible systemsClojure multimethods decouple polymorphism from OO and typesSupports multiple taxonomiesDispatches via static, dynamic or external properties, metadata, etcConcurrency and the multi-core futureImmutability makes much of the problem go awayShare freely between threadsBut changing state a reality for simulations and for in-program proxies to the outside worldLocking is too hard to get right over and over againClojure's software transactional memory and agent systems do the hard partIn short, I think Clojure occupies a unique niche as a functional Lisp for the JVM with strong concurrency support.	→	PolymorphismはSwitch声明、構造マッチングその他が伸長可能なもろいシステムPolymorphism産出高を与えるという良いことです、柔軟なシステムClojureマルチ方法は静的であるか、ダイナミックであるか、外部の所有物（メタデータ）を通してポリエステル繊維モルフィズムをOOとタイプSupportsチェーン店分類学Dispatchesから分離します。そして、その他Concurrencyとマルチコア将来Immutabilityは問題の多くを去らせます自由に糸の間でシェアしかし変わることが何度も何度もClojureのソフトウェア処理の記憶を正しくするにはあまりに、シミュレーションのための、そして、外界Lockingへのプログラムの代理のための現実が難しい、そして、薬品系が難しい役をすると述べます
Check out some of the features	→	特徴のいくらかをチェックしてください。


■ http://clojure.org/features
Features	→	特集
Clojure has a set of useful features that together form a simple, coherent, and powerful tool.	→	Clojureには、単純で、首尾一貫して、強力なツールを一緒に作る一組の役に立つ特徴があります。
In Clojure you'll find ideas from Lisp, ML, Haskell, and others, but the end result is unique.	→	Clojureに、あなたはLISP、ML、ハスケル、その他から考えを見つけます、しかし、結果はユニークです。
This section is a brief, non-comprehensive tour of some of the features of Clojure.	→	このセクションは、Clojureの特徴のいくらかの短い、非広範囲のツアーです。
Consult the reference for more details.	→	詳細は引用を参照してください。
Dynamic Development	→	ダイナミックな発展
Functional Programming	→	関数型プログラミング
Lisp	→	LISP
Runtime Polymorphism	→	実行時Polymorphism
Concurrent Programming	→	コンカレント・プログラミング
Hosted on the JVM	→	JVMで主催されます。

■ http://clojure.org/dynamic

Dynamic Development	→	ダイナミックな発展
First and foremost, Clojure is dynamic.	→	まっさきに、Clojureはダイナミックです。
That means that a Clojure program is not just something you compile and run, but something with which you can interact.	→	つまり、Clojureプログラムは、ちょうどあなたが編集して、走らせる何かでなく、あなたが交流することができる何かです。
Clojure is not a language abstraction, but an environment, where almost all of the language constructs are reified, and thus can be examined and changed.	→	Clojureは言語抽象概念でなく、環境です、そこで、言語構成概念のほぼ全てはreifiedされて、このように調べられることができて、変わることができます。
This leads to a substantially different experience from running a program, examining its results (or failures) and trying again.	→	プログラムを実行して、その結果（または失敗）を調べて、再びためすこととかなり異なる経験に、これは至ります。
In particular, you can grow your program, with data loaded, adding features, fixing bugs, testing, in an unbroken stream.	→	特に、データをロードして、あなたはプログラムを発達させることができます。そして、特徴を加えます。そして、完全な流れでバグ（テスト）を修正します。
The REPL	→	REPL
While Clojure can be embedded in a Java application, or used as a scripting language, the primary programming interface is the Read-Eval-Print-Loop (REPL).	→	ClojureがJavaアプリケーションに埋め込まれることができるか、スクリプト言語として使われることができる間、主要なプログラミング・インターフェースはRead-Eval-Print-Loop（REPL）です。
This is a simple console interface that allows you to enter and execute commands, and examine their results.	→	これは、司令部に入って、実行して、彼らの結果を調べることができる単純なコンソール・インターフェースです。
You can start the Clojure REPL like this, and then follow along trying the samples in this feature tour:	→	あなたはこのようにClojure REPLを始めることができて、そして、この特徴ツアーでサンプルをためすことに沿ってあとに続きます：

$ java -cp clojure.jar clojure.main

これは、このようにあなたに注意をします：

user=>

大部分のClojure命令は、形（命令arguments*）をとります。
それをためしてください：

(def x 6)
-> #'user/x
(def y 36)
-> #'user/y
(+ x y)
-> 42

基本
Clojureには、任意の精度整数、ひも、比率、ダブルス、性格、シンボル、キーワードがあります。

(* 12345678 12345678)
-> 152415765279684
"string"
-> "string"
22/7
-> 22/7
3.14159
-> 3.14159
\a
-> \a
'symbol
-> symbol
:keyword
-> :keyword
;a comment


Dynamic Compilation	→	ダイナミックな編集
Clojure is a compiled language, so one might wonder when you have to run the compiler.	→	Clojureは編集された言語であるので、人はあなたがいつコンパイラを実行しなければならないかについて疑問に思うかもしれません。
You don't.	→	あなたは、そうしません。
Anything you enter into the REPL or load using load-file is automatically compiled to JVM bytecode on the fly.	→	REPLまたはロード・ファイルを使用しているロードに、あなたが入れる何でも、自動的にその場でJVMバイトコードに自動的に編集されます。
Compiling ahead-of-time is also possible, but not required	→	事前に編集することができもするが、要求しませんでした。



■ http://clojure.org/functional_programming

Functional Programming	→	関数型プログラミング
Clojure is a functional programming language.	→	Clojureは、関数型言語です。
It provides the tools to avoid mutable state, provides functions as first-class objects, and emphasizes recursive iteration instead of side-effect based looping.	→	それは変わりやすい州を避けるためのツールを提供して、第一級物として機能を提供して、副作用ベースのルーピングの代わりに再帰的な繰り返しを強調します。
Clojure is impure, in that it doesn't force your program to be referentially transparent, and doesn't strive for 'provable' programs.	→	Clojureは、それがあなたのプログラムに関連してトランスペアレントなことを強いないという点で汚くて、『証明できる』プログラムのために努力しません。
The philosophy behind Clojure is that most parts of most programs should be functional, and that programs that are more functional are more robust.	→	Clojureの後の哲学は大部分のプログラムの大半が機能的でなければならないということです、そして、より機能的であるそのプログラムはより強力です。
First-class functionsfn creates a function object.	→	第一級機能fnは、機能物をつくります。
It yields a value like any other - you can store it in a var, pass it to functions etc	→	それは他のもののような価値を与えます－あなたはそれを1バールに保管することができて、機能その他にそれを通過します。

(def hello (fn [] "Hello world"))
-> #'user/hello
(hello)
-> "Hello world"

defn is a macro that makes defining functions a little simpler.	→	defnは、機能を定めることを少しより単純にするマクロです。
Clojure supports arity overloading in a single function object, self-reference, and variable-arity functions using &:	→	arityに一つの機能で物（自己言及）にオーバーロードするClojure支持物、そして、可変的なarity機能使うこと∥と：

;trumped-up example
(defn argcount
  ([] 0)
  ([x] 1)
  ([x y] 2)
  ([x y & more] (+ (argcount x y) (count more))))
-> #'user/argcount
(argcount)
-> 0
(argcount 1)
-> 1
(argcount 1 2)
-> 2
(argcount 1 2 3 4 5)
-> 5


You can create local names for values inside a function using let.	→	あなたは、使用することがした機能の中に、価格のローカル名前をつくることができます。
The scope of any local names is lexical, so a function created in the scope of local names will close over their values:	→	どんなローカル名前の範囲でも語彙的であるので、ローカル名前の範囲で作成される機能は彼らの値以上閉まります：

(defn make-adder [x]
  (let [y x]
    (fn [z] (+ y z))))
(def add2 (make-adder 2))
(add2 4)
-> 6

Locals created with let are not variables.	→	そうさせられて創造される地方住民は、変数でありません。
Once created their values never change!	→	一度、つくられて彼らの価格は、決して変わりません！
Immutable Data Structures	→	不変のデータ構造
The easiest way to avoid mutating state is to use immutable data structures.	→	州を変異させることを避ける最も簡単な方法は、不変のデータ構造を使用することです。
Clojure provides a set of immutable lists, vectors, sets and maps.	→	Clojureは、一組の不変のリスト、ベクトル、セットと地図を提供します。
Since they can't be changed, 'adding' or 'removing' something from an immutable collection means creating a new collection just like the old one but with the needed change.	→	彼らが変わることができないので、何かを不変のコレクションから『加える』か、『取り除く』ことは必要とされた変化でまるで古いもののような新しいコレクションを以外作成することを意味します。
Persistence is a term used to describe the property wherein the old version of the collection is still available after the 'change', and that the collection maintains its performance guarantees for most operations.	→	持続は、コレクションの古いバージョンがまだ『変化』の後利用できる、そして、コレクションが大部分の活動に対するそのパフォーマンス保証を維持する資産を記述するのに用いられる語です。
Specifically, this means that the new version can't be created using a full copy, since that would require linear time.	→	具体的には、それが線形時間を必要とする時から、これは、新しいバージョンが完全なコピーを使って作成されることができないことを意味します。
Inevitably, persistent collections are implemented using linked data structures, so that the new versions can share structure with the prior version.	→	必然的に、持続的なコレクションは結ばれたデータ構造を使用して実行されます、そのため、新しいバージョンは構造を先のバージョンと共有することができます。
Singly-linked lists and trees are the basic functional data structures, to which Clojure adds a hash map, set and vector both based upon array mapped hash tries.	→	単独でにリンクされたリストと木は、基本的な機能的なデータ構造（両方とも、図にされたハッシュがためす配列に基づくハッシュ・マップ、セットとベクトルを、Clojureは加えます）です。
The collections have readable representations and common interfaces:	→	コレクションには、読み込み可能な表現と一般のインターフェースがあります：

(let [my-vector [1 2 3 4]
      my-map {:fred "ethel"}
      my-list (list 4 3 2 1)]
  (list
    (conj my-vector 5)
    (assoc my-map :ricky "lucy")
    (conj my-list 5)
    ;the originals are intact
    my-vector
    my-map
    my-list))
-> ([1 2 3 4 5] {:ricky "lucy", :fred "ethel"} (5 4 3 2 1) [1 2 3 4] {:fred "ethel"} (4 3 2 1))

Applications often need to associate attributes and other data about data that is orthogonal to the logical value of the data.	→	アプリケーションは、しばしば、データの論理的値に対して直角であるデータについて特質と他のデータを結びつける必要があります。
Clojure provides direct support for this metadata.	→	Clojureは、直接の支持をこのメタデータに提供します。
Symbols, and all of the collections, support a metadata map.	→	シンボル（本当にコレクションの）は、メタデータ・マップを支えます。
It can be accessed with the meta function.	→	それは、メタ機能でアクセスされることができます。
Metadata does not impact equality semantics, nor will metadata be seen in operations on the value of a collection.	→	メタデータは平等意味論に影響を与えませんし、メタデータはコレクションの価値に関して活動において見られません。
Metadata can be read, and can be printed	→	メタデータは読まれることができて、印刷されることができます。

(def v [1 2 3])
(def attributed-v (with-meta v {:source :trusted}))
(:source (meta attributed-v))
-> :trusted
(= v attributed-v)
-> true

Extensible Abstractions	→	伸長可能な抽象概念
Clojure uses Java interfaces to define its core data structures.	→	Clojureは、その中心的なデータ構造を定めるために、Javaインターフェースを使用します。
This allows for extensions of Clojure to new concrete implementations of these interfaces, and the library functions will work with these extensions.	→	これはこれらのインターフェースの新しい具体的な機能にClojureの拡張を考慮に入れます、そして、図書館機能はこれらの機能拡張で動作します。
This is a big improvement vs. hardwiring a language to the concrete implementations of its data types.	→	これは、そのデータの具体的な実現例への言語がタイプする大きい改善対コンピュータ内部の電子部品間の結線接続です。
A good example of this is the seq interface.	→	これの良い例は、seqインターフェースです。
By making the core Lisp list construct into an abstraction, a wealth of library functions are extended to any data structure that can provide a sequential interface to its contents.	→	中心的なLISPリスト構成概念を抽象概念にすることによって、連続したインターフェースをその内容に提供することができるどんなデータ構造にでも、豊かな図書館機能は応用されます。
All of the Clojure data structures can provide seqs.	→	Clojureデータ構造の全ては、seqsを提供することができます。
Seqs can be used like iterators or generators in other languages, with the significant advantage that seqs are immutable and persistent.	→	seqsが不変で持続的である有意な有利な条件で、Seqsが他の言語で反復子または発電機のように使われることができます。
Seqs are extremely simple, providing a first function, which return the first item in the sequence, and a rest function which returns the rest of the sequence, which is itself either a seq or nil	→	Seqsはとても単純です。そして、残りのシーケンスを返す最初の機能（それはシーケンスぶりのアイテムを返します）と休み機能を提供します。そして、それはそれ自体seqか無です。

(let [my-vector [1 2 3 4]
      my-map {:fred "ethel" :ricky "lucy"}
      my-list (list 4 3 2 1)]
  [(first my-vector)
   (rest my-vector)
   (keys my-map)
   (vals my-map)
   (first my-list)
   (rest my-list)])
-> [1 (2 3 4) (:ricky :fred) ("lucy" "ethel") 4 (3 2 1)]

Clojure図書館機能の多くは、ゆったりとseqsを生じて、消費します：

;サイクルは、『無限』seqを生じます！
;cycle produces an 'infinite' seq!
(take 15 (cycle [1 2 3 4]))
-> (1 2 3 4 1 2 3 4 1 2 3 4 1 2 3)

You can define your own lazy seq-producing functions using the lazy-seq macro, which takes a body of expressions that will be called on demand to produce a list of 0 or more items. Here's a simplified take:

(defn take [n coll]
  (lazy-seq
    (when (pos? n)
      (when-let [s (seq coll)]
       (cons (first s) (take (dec n) (rest s)))))))


Recursive Looping	→	再帰的なルーピング
In the absence of mutable local variables, looping and iteration must take a different form than in languages with built-in for or while constructs that are controlled by changing state.	→	変わりやすい局所変数がない場合、ルーピングと繰り返しは、作り付け家具による言語のより異なる形をとらなければなりませんまたは、その一方で∥州を変えることによってコントロールされる構成概念。
In functional languages looping and iteration are replaced / implemented via recursive function calls.	→	関数型言語では、ルーピングと繰り返しは、とって代わられて/再帰的な機能呼び出しを通して実行されます。
Many such languages guarantee that function calls made in tail position do not consume stack space, and thus recursive loops utilize constant space.	→	そのような言語が尾位置でなされるその機能呼び出しに保証する多くはスタック・スペースを消費しません、そして、このように、再帰的ループは恒常的なスペースを利用します。
Since Clojure uses the Java calling conventions, it cannot, and does not, make the same tail call optimization guarantees.	→	Clojureが大会を招集しているJavaを使用するので、それは同じ尾を最適化を保証と呼ばせることができなくて、ません。
Instead, it provides the recur special operator, which does constant-space recursive looping by rebinding and jumping to the nearest enclosing loop or function frame.	→	その代わりに、それは備えをします繰り返されます特別なオペレーター（最も近い囲んでいるループまたは機能フレームを再結合することとジャンプによって、一定にスペース再帰的なルーピングをします）。
While not as general as tail-call-optimization, it allows most of the same elegant constructs, and offers the advantage of checking that calls to recur can only happen in a tail position	→	尾-呼び出し-最適化ほど一般的でない間、それは大部分の同じエレガントな構成概念を許して、繰り返されるという要求が尾位置で起こることができるだけのことを確認することの長所を提供します。


(defn my-zipmap [keys vals]
  (loop [my-map {}
         my-keys (seq keys)
         my-vals (seq vals)]
    (if (and my-keys my-vals)
      (recur (assoc my-map (first my-keys) (first my-vals))
             (next my-keys)
             (next my-vals))
      my-map)))
(my-zipmap [:a :b :c] [1 2 3])
-> {:b 2, :c 3, :a 1}


相互再帰が要求される状況のために、繰り返されます使われることができません。
その代わりに、トランポリンは良いオプションである場合があります。

■ http://clojure.org/lisp

Clojure as a dialect of Lisp	→	LISPの方言としてのClojure
Clojure is a member of the Lisp family of languages.	→	Clojureは、言語のLISP家族のメンバーです。
Many of the features of Lisp have made it into other languages, but Lisp's approach to code-as-data and its macro system still set it apart.	→	LISPの特徴の多くはそれを他の言語にしました、しかし、データとしてのコードへのLISPのアプローチとそのマクロ・システムはまだそれを引き離します。
Clojure extends the code-as-data system beyond parenthesized lists (s-expressions) to vectors and maps.	→	Clojureは、ベクトルと地図に括弧に入れられたリスト（s-表現）を越えて、データとしてのコード・システムを広げます。
Thus vectors and maps can be used in macro syntax, have literal reader representations etc.	→	このように、ベクトルと地図が、マクロ構文で使われることができて、文字通りの読者表現その他を持ちます。
Lisp data, and thus Lisp code, is read by the reader.	→	データを舌足らずに言ってください、そして、このように、LISPコードは読者によって読まれます。
The result of reading is the data structure represented by the forms.	→	読書の結果は、形によって意味されるデータ構造です。
Clojure can compile data structures that represent code, and as part of that process it looks for calls to macros.	→	Clojureはコードを意味するデータ構造をコンパイルすることができます、そして、そのプロセスの一部として、それはマクロに呼び出しを探します。
When it sees one, it calls the macro, passing the forms themselves as arguments, then uses the return value of the macro in place of the macro itself.	→	1を見るとき、それから、マクロが、議論として形に自分自身を渡して、マクロそのものの代わりにマクロの戻り値を使うと、それは叫びます。
Thus macros are functions that are called at compile time to perform transformations of code.	→	このように、マクロは、コードの変化を実行するためにコンパイル時で呼ばれる機能です。
Since code is data, all of the Clojure library is available to assist in the transformation.	→	コードがデータであるので、Clojure図書館の全ては変化面で助けることが可能です。
Thus macros allow Lisps, and Clojure, to support syntactic abstraction.	→	このように、統語的な抽象化を支持するために、マクロはLispsとClojureを許します。
You use macros for the same reasons you use functions - to eliminate repetition in your code.	→	あなたは機能を使用する同じ理由のためにマクロを使用します－あなたのコードで繰り返しを除きます。
Macros should be reserved for situations for which functions are insufficient, e.g. when you need to control evaluation, generate identifiers etc. Many of the core constructs of Clojure are not built-in primitives but macros just like users can define.	→	例えばあなたが評価をコントロールする必要があるとき、マクロは機能が不十分である状況のために予約でなければなりません識別子その他を生み出します、ユーザーが定義することができるように、Clojureの中心的な構成概念のManyはビルトイン・プリミティブでなくマクロです。
Here's and:	→	乾杯、そして：

(defmacro and
  ([] true)
  ([x] x)
  ([x & rest]
    `(let [and# ~x]
       (if and# (and ~@rest) and#))))

構文引用句（）（形が彼らが生み出す形を模倣するマクロを定めることを簡単にします）の用法に注意してください。

■ http://clojure.org/runtime_polymorphism

Runtime Polymorphism	→	実行時Polymorphism
Systems that utilize runtime polymorphism are easier to change and extend.	→	実行時ポリエステル繊維モルフィズムを利用するシステムは、変えて、広げるのがより簡単です。
Clojure supports polymorphism in several ways:	→	Clojureは、いくつかの点でポリエステル繊維モルフィズムを支持します：
Most core infrastructure data structures in the Clojure runtime are defined by Java interfaces.	→	Clojure実行時の大部分の中心的な基盤データ構造は、Javaインターフェースによって定義されます。
Clojure supports the generation of implementations of Java interfaces in Clojure using proxy (see JVM Hosted).	→	代理（JVM Hostedを見ます）を用いたClojureで、ClojureはJavaインターフェースの機能の生成を支持します。
The Clojure language supports polymorphism along both class and custom hierarchies with multimethods.	→	Clojure言語は、マルチ方法でクラスとカスタムメイドの階層に沿ってポリエステル繊維モルフィズムをサポートします。
The Clojure language also supports a faster form of polymorphism with protocols (but limited only to class polymorphism to take advantage of the JVMs existing capabilities for invocation).	→	プロトコル（しかし、JVMの有利さに祈りの既存の資格を持っていくためにクラス・ポリエステル繊維モルフィズムだけに限られる）で、Clojure言語も、ポリエステル繊維モルフィズムのより速い形をサポートします。
Clojure multimethods are a simple yet powerful mechanism for runtime polymorphism that is free of the trappings of OO, types and inheritance.	→	Clojureマルチ方法は、OO、タイプと遺産の装飾がない実行時ポリエステル繊維モルフィズムのための単純であるが、強力なメカニズムです。
The basic idea behind runtime polymorphism is that a single function designator dispatches to multiple independently-defined function definitions based upon some value of the call.	→	実行時ポリエステル繊維モルフィズムの後の基本的な考えは、独りの機能指名者が独立してチェーン店に急ぐということです定義された呼び出しの若干の価値に基づく機能定義。
For traditional single-dispatch OO languages that value is the type of the 'receiver' or 'this'.	→	伝統的な一回の急送OO言語については、その価値は、『レシーバー』または『これ』のタイプです。
CLOS generic functions extend dispatch value to a composite of the type or value of multiple arguments, and are thus multimethods.	→	一般的な機能が広げるCLOSは、複数の議論のタイプまたは価値の複合物に価格を送って、このようにマルチ方法です。
Clojure multimethods go further still to allow the dispatch value to be the result of an arbitrary function of the arguments.	→	Clojureマルチ方法は、急送価値を議論の任意の機能の結果でいさせるために、さらにまだ行きます。
Clojure does not support implementation inheritance.	→	Clojureは、実施遺産を支えません。
Multimethods are defined using defmulti, which takes the name of the multimethod and the dispatch function.	→	Multimethodsはdefmultiを使って定められます。そして、それはマルチ方法と急送機能の名前をとります。
Methods are independently defined using defmethod, passing the multimethod name, the dispatch value and the function body	→	方法はdefmethodを使って独立して定められます。そして、マルチ方法名、急送価値と機能体を渡します。

(defmulti encounter (fn [x y] [(:Species x) (:Species y)]))
(defmethod encounter [:Bunny :Lion] [b l] :run-away)
(defmethod encounter [:Lion :Bunny] [l b] :eat)
(defmethod encounter [:Lion :Lion] [l1 l2] :fight)
(defmethod encounter [:Bunny :Bunny] [b1 b2] :mate)
(def b1 {:Species :Bunny :other :stuff})
(def b2 {:Species :Bunny :other :stuff})
(def l1 {:Species :Lion :other :stuff})
(def l2 {:Species :Lion :other :stuff})
(encounter b1 b2)
-> :mate
(encounter b1 l1)
-> :run-away
(encounter l1 b1)
-> :eat
(encounter l1 l2)
-> :fight



Multimethods are in every respect fns, e.g. can be passed to map etc.	→	Multimethodsはあらゆる点でfnsで、例えば地図その他に通過されることができます。
Similar to interfaces, Clojure protocols define only function specifications (no implementation) and allow types to implement multiple protocols.	→	インターフェースと同様で、Clojureプロトコルは機能仕様（実施でない）だけを定めて、タイプを複数のプロトコルを実行させます。
Additionally, protocols are open to later dynamic extension for new types.	→	その上、プロトコルは新しいタイプのために後のダイナミックな拡張を受け入れます。
Protocols are limited just to dispatch on class type to take advantage of the native Java performance of polymorphic method calls.	→	多形方法呼び出しの生まれつきのJava実行を利用するために、プロトコルはクラス・タイプ上でちょうど急送に限られています。
For more details, see the protocols page	→	詳細は、プロトコル・ページを参照してください。

■ http://clojure.org/concurrent_programming

Concurrent Programming	→	コンカレント・プログラミング
Today's systems have to deal with many simultaneous tasks and leverage the power of multi-core CPUs.	→	今日のシステムは多くの同時の仕事に対処しなければならなくて、マルチコアＣＰＵの力に影響を及ぼさなければなりません。
Doing so with threads can be very difficult due to the complexities of synchronization.	→	糸でそうすることは、同期の複雑さのために、非常に難しくありえます。
Clojure simplifies multi-threaded programming in several ways.	→	Clojureは、いくつかの点でマルチスレッドのプログラミングを単純化します。
Because the core data structures are immutable, they can be shared readily between threads.	→	中心的なデータ構造が不変であるので、彼らはすぐに糸で分配されることができます。
However, it is often necessary to have state change in a program.	→	しかし、プログラムにおける状態変化があることが、しばしば必要です。
Clojure, being a practical language, allows state to change but provides mechanism to ensure that, when it does so, it remains consistent, while alleviating developers from having to avoid conflicts manually using locks etc. The software transactional memory system (STM), exposed through dosync, ref, set, alter, et al, supports sharing changing state between threads in a synchronous and coordinated manner.	→	Clojure（実用的な言葉遣いであること）は、州が変わるのを許すが、それを確実にするために、メカニズムを提供します。そのとき、それはそうします、それは首尾一貫したままです、手でロックその他を使っている紛争を避けなければならないことから開発者を軽減している間、ソフトウェア処理の記憶システム（STM）は終わりまでdosync、参照、セットを露出させました、変えます、ほか、同期で調整方法で変わっている州を糸で分配している支持物。
The agent system supports sharing changing state between threads in an asynchronous and independent manner.	→	薬品系は、非同期で独立した方法で変わっている州を糸で分配することをサポートします。
The atoms system supports sharing changing state between threads in a synchronous and independent manner.	→	原子系は、同期で独立した方法で変わっている州を糸で分配することをサポートします。
The dynamic var system, exposed through def, binding, et al, supports isolating changing state within threads.In all cases, Clojure does not replace the Java thread system, rather it works with it.	→	ダイナミックなバール・システムは終わりまでdef、装丁、ほかを露出させました。そして、支持物が筋の中で変わっている州を孤立させました。
Clojure functions are java.util.concurrent.	→	Clojure機能は、java.util.concurrentです。
Callable, therefore they work with the Executor framework etc.	→	呼ぶことができて、したがって、彼らはExecutorフレームワークその他で働きます。
Most of this is covered in more detail in the concurrency screencast.	→	これの最大限は、並列性screencastで更に詳細にカバーされます。
Refs are mutable references to objects.	→	レフリーは、物への変わりやすい言及です。
They can be ref-set or altered to refer to different objects during transactions, which are delimited by dosync blocks.	→	彼らは参照-セットでありえるか、業務の間、異なる物に言及するために変わりました。そして、それはdosyncブロックによって区切られます。
All ref modifications within a transaction happen or none do.Also, reads of refs within a transaction reflect a snapshot of the reference world at a particular point in time, i.e. each transaction is isolated from other transactions.	→	業務の範囲内のすべての参照修正は、起こります、または、何もしません。Also、特定の時（すなわち各々の業務）の参照世界のスナップショットが他の業務から分離されると、業務の範囲内のレフリーの読み物は、思います。
If a conflict occurs between 2 transactions trying to modify the same reference, one of them will be retried.	→	コンフリクトが同じ参照を修正しようとしている2つの業務の間で起こるならば、彼らのうちの1人は再び試みられます。
All of this occurs without explicit locking.	→	これの全ては、露骨にロックすることなく起こります。
In this example a vector of Refs containing integers is created (refs), then a set of threads are set up (pool) to run a number of iterations of incrementing every Ref (tasks).	→	この例では、整数を含んでいるRefsのベクトルは作成されます（レフリー）、そして、あらゆるRef（仕事）を増加させるいくつかの繰り返しを走らせるために、一組の糸は準備されます（プール）。
This creates extreme contention, but yields the correct result.	→	これは最大の争いを引き起こすが、正しい結果を与えます。
No locks!	→	いいえはロックします！

(import '(java.util.concurrent Executors))

(defn test-stm [nitems nthreads niters]
  (let [refs  (map ref (repeat nitems 0))
        pool  (Executors/newFixedThreadPool nthreads)
        tasks (map (fn [t]
                      (fn []
                        (dotimes [n niters]
                          (dosync
                            (doseq [r refs]
                              (alter r + 1 t))))))
                   (range nthreads))]
    (doseq [future (.invokeAll pool tasks)]
      (.get future))
    (.shutdown pool)
    (map deref refs)))

(test-stm 10 10 10000)
-> (550000 550000 550000 550000 550000 550000 550000 550000 550000 550000)


In typical use refs can refer to Clojure collections, which, being persistent and immutable, efficiently support simultaneous speculative 'modifications' by multiple transactions.	→	典型的使用法では、レフリーはClojureコレクションに言及することができます。そして、それは、持続的で不変で、同時思惑的な『修正』を複数の業務で効率的に支えます。
Mutable objects should not be put in refs.	→	変わりやすい物は、レフリーに入れられてはいけません。
By default Vars are static, but per-thread bindings for Vars defined with metadata mark them as dynamic.	→	デフォルトで、Varsは動かないです、しかし、ダイナミックであるように、メタデータで定められるVarsのための糸につき装丁は彼らをマークします。
Dynamic vars are also mutable references to objects.	→	ダイナミックなバールは、物への変わりやすい言及でもあります。
They have a (thread-shared) root binding which can be established by def, and can be set using set!, but only if they have been bound to a new storage location thread-locally using binding.	→	彼らは、defによって確立されることができる、（糸共有された）根装丁を持って、セットを使って配置されることができます！彼らが糸地元で装丁を使っている新しい貯蔵場所に行くところの場合だけ、しかし。
Those bindings and any subsequent modifications to those bindings will only be seen within the thread by code in the dynamic scope of the binding block.	→	それらの装丁とそれらの装丁へのどんな以降の修正でも、拘束的なブロックのダイナミックな範囲で、コードによって筋の中で見られるだけです。
Nested bindings obey a stack protocol and unwind as control exits the binding block	→	支配が拘束的なブロックを出て、入れ子になった包帯はスタック・プロトコルに従って、ほどけます。

(def ^:dynamic *v*)

(defn incv [n] (set! *v* (+ *v* n)))

(defn test-vars [nthreads niters]
  (let [pool (Executors/newFixedThreadPool nthreads)
        tasks (map (fn [t]
                     #(binding [*v* 0]
                        (dotimes [n niters]
                          (incv t))
                        *v*))
                   (range nthreads))]
      (let [ret (.invokeAll pool tasks)]
        (.shutdown pool)
        (map #(.get %) ret))))

(test-vars 10 1000000)
-> (0 1000000 2000000 3000000 4000000 5000000 6000000 7000000 8000000 9000000)
(set! *v* 4)
-> java.lang.IllegalStateException: Can't change/establish root binding of: *v* with set


Dynamic vars provide a way to communicate between different points on the call stack without polluting the argument lists and return values of the intervening calls.In addition, dynamic vars support a flavor of context-oriented programming.	→	ダイナミックなバールは、中の呼び出しの議論リストと戻り値を汚染することなく呼び出しスタックの上で異なる点の間で通信する方法を提供します。
Because fns defined with defn are stored in vars, they too can be dynamically rebound:	→	defnで定められるfnsがバールに保管されるので、彼らもダイナミックに再結合されることができます：

(defn ^:dynamic say [& args]
  (apply str args))

(defn loves [x y]
  (say x " loves " y))

(defn test-rebind []
  (println (loves "ricky" "lucy"))
  (let [say-orig say]
    (binding [say (fn [& args]
                      (println "Logging say")
                      (apply say-orig args))]
      (println (loves "fred" "ethel")))))

(test-rebind)

ricky loves lucy
Logging say
fred loves ethel


■ http://clojure.org/jvm_hosted

Hosted on the JVM	→	JVMで主催されます
Clojure is designed to be a hosted language, sharing the JVM type system, GC, threads etc. It compiles all functions to JVM bytecode.	→	主催された言語、JVMタイプ・システムを共有すること、GC、糸その他であるように、Clojureは設計されています。そして、ItはJVMバイトコードにすべての機能をコンパイルします。
Clojure is a great Java library consumer, offering the dot-target-member notation for calls to Java.	→	Clojureは偉大なJava図書館消費者です。そして、Javaに点-目標会員表記法を呼び出しに対して提供します。
Class names can be referenced in full, or as non-qualified names after being imported.	→	クラス名は、インポートされた後に、完全であるか、資格がない名前でリファレンスをつけられることができます。
Clojure supports the dynamic implementation of Java interfaces and classes using reify and proxy:	→	Clojureは、Javaインターフェースのダイナミックな実施とreifyと代理を用いたクラスをサポートします：
Here's a small Swing app:	→	小さなSwingアプリは、ここにあります：

(import '(javax.swing JFrame JLabel JTextField JButton)
        '(java.awt.event ActionListener)
        '(java.awt GridLayout))
(defn celsius []
  (let [frame (JFrame. "Celsius Converter")
        temp-text (JTextField.)
        celsius-label (JLabel. "Celsius")
        convert-button (JButton. "Convert")
        fahrenheit-label (JLabel. "Fahrenheit")]
    (.addActionListener
     convert-button
     (reify ActionListener
            (actionPerformed
             [_ evt]
             (let [c (Double/parseDouble (.getText temp-text))]
               (.setText fahrenheit-label
                         (str (+ 32 (* 1.8 c)) " Fahrenheit"))))))
    (doto frame
      (.setLayout (GridLayout. 2 2 3 3))
      (.add temp-text)
      (.add celsius-label)
      (.add convert-button)
      (.add fahrenheit-label)
      (.setSize 300 80)
      (.setVisible true))))
(celsius)


http://clojure.org/file/view/celsius.jpeg/34601359/celsius.jpeg
